{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PyNetBox Documentation","text":"<p>Python API client library for NetBox.</p>"},{"location":"#overview","title":"Overview","text":"<p>PyNetBox is a Python client library that provides a simple and intuitive interface to interact with the NetBox REST API. It abstracts the complexity of making HTTP requests and provides a Pythonic way to work with NetBox data.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Intuitive API: Access NetBox endpoints through simple Python attributes</li> <li>Full CRUD Support: Create, read, update, and delete NetBox objects</li> <li>Threading Support: Parallel requests for improved performance on large queries</li> <li>Filter Validation: Optional strict validation of filters against NetBox's OpenAPI spec</li> <li>Custom Sessions: Support for custom HTTP sessions with SSL, timeouts, and retries</li> <li>Branch Support: Context manager for NetBox branching plugin</li> <li>Comprehensive Coverage: Support for all NetBox apps (DCIM, IPAM, Circuits, Virtualization, etc.)</li> </ul>"},{"location":"#netbox-version-compatibility","title":"NetBox Version Compatibility","text":"<p>Version Requirements</p> <p>Version 6.7 and later of pyNetBox only supports NetBox 3.3 and above.</p> <p>Each pyNetBox version has been tested with its corresponding NetBox version:</p> NetBox Version PyNetBox Version 4.5 7.6.0 4.4 7.5.0 4.3 7.5.0 4.2 7.5.0 4.1 7.5.0 4.0.6 7.4.1 4.0.0 7.3.4 3.7 7.3.0 3.6 7.2.0 3.5 7.1.0 3.3 7.0.0"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import pynetbox\n\n# Initialize the API connection\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n)\n\n# Query all devices\ndevices = nb.dcim.devices.all()\nfor device in devices:\n    print(device.name)\n\n# Filter devices\nleaf_switches = nb.dcim.devices.filter(role='leaf-switch')\n\n# Get a specific device\ndevice = nb.dcim.devices.get(name='spine1')\n\n# Create a new device\nnew_device = nb.dcim.devices.create(\n    name='new-device',\n    device_type=1,\n    site=1,\n    device_role=1\n)\n\n# Update a device\ndevice.serial = 'ABC123'\ndevice.save()\n</code></pre>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>GitHub Issues: Report bugs or request features at github.com/netbox-community/pynetbox/issues</li> <li>Documentation: Full API reference and guides available in this documentation</li> <li>Source Code: Available at github.com/netbox-community/pynetbox</li> </ul>"},{"location":"IPAM/","title":"IPAM","text":"<p>This page documents special methods available for IPAM models in pyNetBox.</p> <p>Standard API Operations</p> <p>Standard CRUD operations (<code>.all()</code>, <code>.filter()</code>, <code>.get()</code>, <code>.create()</code>, <code>.update()</code>, <code>.delete()</code>) follow NetBox's REST API patterns. Refer to the NetBox API documentation for details on available endpoints and filters.</p>"},{"location":"IPAM/#prefixes","title":"Prefixes","text":""},{"location":"IPAM/#available-ips","title":"Available IPs","text":"<p>The <code>available_ips</code> property provides access to view and create available IP addresses within a prefix.</p> <p>Examples: <pre><code>prefix = nb.ipam.prefixes.get(prefix='10.0.0.0/24')\n\n# List available IP addresses\navailable = prefix.available_ips.list()\n# [10.0.0.1/24, 10.0.0.2/24, 10.0.0.3/24, ...]\n\n# Create a single IP from available pool\nnew_ip = prefix.available_ips.create()\n\n# Create multiple IPs\nnew_ips = prefix.available_ips.create([{} for i in range(5)])\n\n# Create IP with specific attributes\nnew_ip = prefix.available_ips.create({\n    'dns_name': 'server01.example.com',\n    'description': 'Web Server',\n    'status': 'active'\n})\n</code></pre></p>"},{"location":"IPAM/#pynetbox.models.ipam.Prefixes.available_ips","title":"<code>pynetbox.models.ipam.Prefixes.available_ips</code>  <code>property</code> <code>readonly</code>","text":"<p>Represents the <code>available-ips</code> detail endpoint.</p> <p>Returns a DetailEndpoint object that is the interface for viewing and creating IP addresses inside a prefix.</p>"},{"location":"IPAM/#pynetbox.models.ipam.Prefixes.available_ips--returns","title":"Returns","text":"<p>DetailEndpoint object.</p>"},{"location":"IPAM/#pynetbox.models.ipam.Prefixes.available_ips--examples","title":"Examples","text":"<pre><code>prefix = nb.ipam.prefixes.get(24)\nprefix.available_ips.list()\n# [10.0.0.1/24, 10.0.0.2/24, 10.0.0.3/24, 10.0.0.4/24, 10.0.0.5/24, ...]\n</code></pre> <p>To create a single IP:</p> <pre><code>prefix = nb.ipam.prefixes.get(24)\nprefix.available_ips.create()\n# 10.0.0.1/24\n</code></pre> <p>To create multiple IPs:</p> <pre><code>prefix = nb.ipam.prefixes.get(24)\ncreate = prefix.available_ips.create([{} for i in range(2)])\n# [10.0.0.2/24, 10.0.0.3/24]\n</code></pre>"},{"location":"IPAM/#available-prefixes","title":"Available Prefixes","text":"<p>The <code>available_prefixes</code> property provides access to view and create available child prefixes within a parent prefix.</p> <p>Examples: <pre><code>prefix = nb.ipam.prefixes.get(prefix='10.0.0.0/16')\n\n# List available child prefixes\navailable = prefix.available_prefixes.list()\n# [10.0.1.0/24, 10.0.2.0/23, 10.0.4.0/22, ...]\n\n# Create a child prefix\nnew_prefix = prefix.available_prefixes.create({\n    'prefix_length': 24,\n    'status': 'active',\n    'description': 'Server subnet'\n})\n\n# Create multiple child prefixes\nnew_prefixes = prefix.available_prefixes.create([\n    {'prefix_length': 24},\n    {'prefix_length': 24},\n    {'prefix_length': 25}\n])\n</code></pre></p>"},{"location":"IPAM/#pynetbox.models.ipam.Prefixes.available_prefixes","title":"<code>pynetbox.models.ipam.Prefixes.available_prefixes</code>  <code>property</code> <code>readonly</code>","text":"<p>Represents the <code>available-prefixes</code> detail endpoint.</p> <p>Returns a DetailEndpoint object that is the interface for viewing and creating prefixes inside a parent prefix.</p> <p>Very similar to <code>available_ips</code>, except that dict (or list of dicts) passed to <code>.create()</code> needs to have a <code>prefix_length</code> key/value specified.</p>"},{"location":"IPAM/#pynetbox.models.ipam.Prefixes.available_prefixes--returns","title":"Returns","text":"<p>DetailEndpoint object.</p>"},{"location":"IPAM/#pynetbox.models.ipam.Prefixes.available_prefixes--examples","title":"Examples","text":"<pre><code>prefix = nb.ipam.prefixes.get(3)\nprefix\n# 10.0.0.0/16\nprefix.available_prefixes.list()\n# [10.0.1.0/24, 10.0.2.0/23, 10.0.4.0/22, 10.0.8.0/21, 10.0.16.0/20, 10.0.32.0/19, 10.0.64.0/18, 10.0.128.0/17]\n</code></pre> <p>Creating a single child prefix:</p> <pre><code>prefix = nb.ipam.prefixes.get(1)\nprefix\n# 10.0.0.0/24\nnew_prefix = prefix.available_prefixes.create(\n    {\"prefix_length\": 29}\n)\n# 10.0.0.16/29\n</code></pre>"},{"location":"IPAM/#ip-ranges","title":"IP Ranges","text":""},{"location":"IPAM/#available-ips_1","title":"Available IPs","text":"<p>The <code>available_ips</code> property provides access to view and create available IP addresses within an IP range.</p> <p>Examples: <pre><code>ip_range = nb.ipam.ip_ranges.get(1)\n\n# List available IPs in range\navailable = ip_range.available_ips.list()\n\n# Create single IP from range\nnew_ip = ip_range.available_ips.create()\n\n# Create multiple IPs\nnew_ips = ip_range.available_ips.create([{} for i in range(10)])\n\n# Create IP with attributes\nnew_ip = ip_range.available_ips.create({\n    'description': 'DHCP reservation',\n    'status': 'reserved'\n})\n</code></pre></p>"},{"location":"IPAM/#pynetbox.models.ipam.IpRanges.available_ips","title":"<code>pynetbox.models.ipam.IpRanges.available_ips</code>  <code>property</code> <code>readonly</code>","text":"<p>Represents the <code>available-ips</code> detail endpoint.</p> <p>Returns a DetailEndpoint object that is the interface for viewing and creating IP addresses inside an ip range.</p>"},{"location":"IPAM/#pynetbox.models.ipam.IpRanges.available_ips--returns","title":"Returns","text":"<p>DetailEndpoint object.</p>"},{"location":"IPAM/#pynetbox.models.ipam.IpRanges.available_ips--examples","title":"Examples","text":"<pre><code>ip_range = nb.ipam.ip_ranges.get(24)\nip_range.available_ips.list()\n# [10.0.0.1/24, 10.0.0.2/24, 10.0.0.3/24, 10.0.0.4/24, 10.0.0.5/24, ...]\n</code></pre> <p>To create a single IP:</p> <pre><code>ip_range = nb.ipam.ip_ranges.get(24)\nip_range.available_ips.create()\n# 10.0.0.1/24\n</code></pre> <p>To create multiple IPs:</p> <pre><code>ip_range = nb.ipam.ip_ranges.get(24)\ncreate = ip_range.available_ips.create([{} for i in range(2)])\n# [10.0.0.2/24, 10.0.0.3/24]\n</code></pre>"},{"location":"IPAM/#vlan-groups","title":"VLAN Groups","text":""},{"location":"IPAM/#available-vlans","title":"Available VLANs","text":"<p>The <code>available_vlans</code> property provides access to view and create available VLANs within a VLAN group.</p> <p>Examples: <pre><code>vlan_group = nb.ipam.vlan_groups.get(name='Production')\n\n# List available VLAN IDs\navailable = vlan_group.available_vlans.list()\n# [10, 11, 12, 13, ...]\n\n# Create a VLAN from available IDs\nnew_vlan = vlan_group.available_vlans.create({\n    'name': 'NewVLAN',\n    'status': 'active'\n})\n# NewVLAN (VID: 10)\n\n# Create VLAN with specific VID (must be in available range)\nnew_vlan = vlan_group.available_vlans.create({\n    'name': 'Servers',\n    'vid': 100,\n    'status': 'active'\n})\n</code></pre></p>"},{"location":"IPAM/#pynetbox.models.ipam.VlanGroups.available_vlans","title":"<code>pynetbox.models.ipam.VlanGroups.available_vlans</code>  <code>property</code> <code>readonly</code>","text":"<p>Represents the <code>available-vlans</code> detail endpoint.</p> <p>Returns a DetailEndpoint object that is the interface for viewing and creating VLANs inside a VLAN group.</p>"},{"location":"IPAM/#pynetbox.models.ipam.VlanGroups.available_vlans--returns","title":"Returns","text":"<p>DetailEndpoint object.</p>"},{"location":"IPAM/#pynetbox.models.ipam.VlanGroups.available_vlans--examples","title":"Examples","text":"<pre><code>vlan_group = nb.ipam.vlan_groups.get(1)\nvlan_group.available_vlans.list()\n# [10, 11, 12]\n</code></pre> <p>To create a new VLAN:</p> <pre><code>vlan_group.available_vlans.create({\"name\": \"NewVLAN\"})\n# NewVLAN (10)\n</code></pre>"},{"location":"IPAM/#asn-ranges","title":"ASN Ranges","text":""},{"location":"IPAM/#available-asns","title":"Available ASNs","text":"<p>The <code>available_asns</code> property provides access to view and create available ASNs within an ASN range.</p> <p>Examples: <pre><code>asn_range = nb.ipam.asn_ranges.get(name='Private ASN Pool')\n\n# List available ASNs\navailable = asn_range.available_asns.list()\n# [64512, 64513, 64514, ...]\n\n# Allocate a single ASN\nnew_asn = asn_range.available_asns.create()\n# 64512\n\n# Allocate multiple ASNs\nnew_asns = asn_range.available_asns.create([{} for i in range(5)])\n</code></pre></p>"},{"location":"IPAM/#pynetbox.models.ipam.AsnRanges.available_asns","title":"<code>pynetbox.models.ipam.AsnRanges.available_asns</code>  <code>property</code> <code>readonly</code>","text":"<p>Represents the <code>available-asns</code> detail endpoint.</p> <p>Returns a DetailEndpoint object that is the interface for viewing and creating ASNs inside an ASN range.</p>"},{"location":"IPAM/#pynetbox.models.ipam.AsnRanges.available_asns--returns","title":"Returns","text":"<p>DetailEndpoint object.</p>"},{"location":"IPAM/#pynetbox.models.ipam.AsnRanges.available_asns--examples","title":"Examples","text":"<pre><code>asn_range = nb.ipam.asn_ranges.get(1)\nasn_range.available_asns.list()\n# [64512, 64513, 64514]\n</code></pre> <p>To create a new ASN:</p> <pre><code>asn_range.available_asns.create()\n# 64512\n</code></pre> <p>To create multiple ASNs:</p> <pre><code>asn_range.available_asns.create([{} for i in range(2)])\n# [64513, 64514]\n</code></pre>"},{"location":"advanced/","title":"Advanced Usage","text":""},{"location":"advanced/#threading","title":"Threading","text":"<p>PyNetBox supports multithreaded calls for <code>.filter()</code> and <code>.all()</code> queries to significantly improve performance when fetching large datasets.</p> <p>NetBox Configuration Required</p> <p>It is highly recommended you have <code>MAX_PAGE_SIZE</code> in your NetBox installation set to anything except <code>0</code> or <code>None</code>. The default value of <code>1000</code> is usually a good value to use.</p>"},{"location":"advanced/#enabling-threading","title":"Enabling Threading","text":"<p>Enable threading globally by passing <code>threading=True</code> to the API initialization:</p> <pre><code>import pynetbox\n\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='your-token',\n    threading=True\n)\n\n# Now all .all() and .filter() calls will use threading\ndevices = nb.dcim.devices.all()  # Fetches pages in parallel\n</code></pre>"},{"location":"advanced/#how-it-works","title":"How It Works","text":"<p>When threading is enabled: - PyNetBox fetches multiple pages of results in parallel - Significantly faster for large result sets - Especially useful for <code>.all()</code> queries that span many pages - Works automatically with pagination</p>"},{"location":"advanced/#example","title":"Example","text":"<pre><code>import pynetbox\nimport time\n\nnb = pynetbox.api('http://localhost:8000', token='your-token')\n\n# Without threading\nstart = time.time()\ndevices = list(nb.dcim.devices.all())\nprint(f\"Without threading: {time.time() - start:.2f}s\")\n\n# With threading\nnb_threaded = pynetbox.api(\n    'http://localhost:8000',\n    token='your-token',\n    threading=True\n)\nstart = time.time()\ndevices = list(nb_threaded.dcim.devices.all())\nprint(f\"With threading: {time.time() - start:.2f}s\")\n</code></pre>"},{"location":"advanced/#filter-validation","title":"Filter Validation","text":"<p>NetBox doesn't validate filters passed to GET API endpoints (<code>.get()</code> and <code>.filter()</code>). If a filter is incorrect, NetBox silently returns the entire database table content, which can be slow and unexpected.</p> <p>PyNetBox can validate filter parameters against NetBox's OpenAPI specification before making the request, raising an exception if a parameter is invalid.</p>"},{"location":"advanced/#enabling-strict-filters-globally","title":"Enabling Strict Filters Globally","text":"<pre><code>import pynetbox\n\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='your-token',\n    strict_filters=True  # Enable validation globally\n)\n\n# This will raise ParameterValidationError\ntry:\n    devices = nb.dcim.devices.filter(non_existing_filter='value')\nexcept pynetbox.core.query.ParameterValidationError as e:\n    print(f\"Invalid filter: {e}\")\n</code></pre>"},{"location":"advanced/#per-request-validation","title":"Per-Request Validation","text":"<p>You can also enable or disable validation on a per-request basis:</p> <pre><code>nb = pynetbox.api('http://localhost:8000', token='your-token')\n\n# Enable for one request (when not globally enabled)\ntry:\n    devices = nb.dcim.devices.filter(\n        non_existing_filter='aaaa',\n        strict_filters=True\n    )\nexcept pynetbox.core.query.ParameterValidationError as e:\n    print(f\"Invalid filter: {e}\")\n\n# Disable for one request (when globally enabled)\nnb_strict = pynetbox.api(\n    'http://localhost:8000',\n    token='your-token',\n    strict_filters=True\n)\n# This won't raise an exception, but returns entire table\ndevices = nb_strict.dcim.devices.filter(\n    non_existing_filter='aaaa',\n    strict_filters=False\n)\n</code></pre>"},{"location":"advanced/#benefits-of-strict-filters","title":"Benefits of Strict Filters","text":"<ul> <li>Catch typos early: Find misspelled filter names before making requests</li> <li>Prevent full table scans: Avoid accidentally fetching entire tables</li> <li>Better error messages: Get clear feedback about invalid parameters</li> <li>Development aid: Helpful during development to ensure correct filter usage</li> </ul>"},{"location":"advanced/#example_1","title":"Example","text":"<pre><code>import pynetbox\n\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='your-token',\n    strict_filters=True\n)\n\n# Valid filter - works fine\ndevices = nb.dcim.devices.filter(site='datacenter1')\n\n# Invalid filter - raises exception\ntry:\n    devices = nb.dcim.devices.filter(iste='datacenter1')  # Typo: 'iste' instead of 'site'\nexcept pynetbox.core.query.ParameterValidationError as e:\n    print(f\"Error: {e}\")\n    # Error: 'iste' is not a valid filter parameter for dcim.devices\n</code></pre>"},{"location":"advanced/#custom-sessions","title":"Custom Sessions","text":"<p>Custom sessions can be used to modify the default HTTP behavior. Below are a few examples, most of them from here.</p>"},{"location":"advanced/#headers","title":"Headers","text":"<p>To set a custom header on all requests. These headers are automatically merged with headers pynetbox sets itself.</p> <p>Example:</p> <pre><code>import pynetbox\nimport requests\nsession = requests.Session()\nsession.headers = {\"mycustomheader\": \"test\"}\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n)\nnb.http_session = session\n</code></pre>"},{"location":"advanced/#ssl-verification","title":"SSL Verification","text":"<p>To disable SSL verification. See the docs.</p> <p>Example:</p> <pre><code>import pynetbox\nimport requests\nsession = requests.Session()\nsession.verify = False\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n)\nnb.http_session = session\n</code></pre>"},{"location":"advanced/#timeouts","title":"Timeouts","text":"<p>Setting timeouts requires the use of Adapters.</p> <p>Example:</p> <pre><code>from requests.adapters import HTTPAdapter\n\nclass TimeoutHTTPAdapter(HTTPAdapter):\n    def __init__(self, *args, **kwargs):\n        self.timeout = kwargs.get(\"timeout\", 5)\n        super().__init__(*args, **kwargs)\n\n    def send(self, request, **kwargs):\n        kwargs['timeout'] = self.timeout\n        return super().send(request, **kwargs)\n\nadapter = TimeoutHTTPAdapter()\nsession = requests.Session()\nsession.mount(\"http://\", adapter)\nsession.mount(\"https://\", adapter)\n\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n)\nnb.http_session = session\n</code></pre>"},{"location":"advanced/#file-uploads-image-attachments","title":"File Uploads (Image Attachments)","text":"<p>Pynetbox supports file uploads for endpoints that accept them, such as image attachments. When you pass a file-like object (anything with a <code>.read()</code> method) to <code>create()</code>, pynetbox automatically detects it and uses multipart/form-data encoding instead of JSON.</p>"},{"location":"advanced/#creating-an-image-attachment","title":"Creating an Image Attachment","text":"<pre><code>import pynetbox\n\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n)\n\n# Attach an image to a device\nwith open('/path/to/image.png', 'rb') as f:\n    attachment = nb.extras.image_attachments.create(\n        object_type='dcim.device',\n        object_id=1,\n        image=f,\n        name='rack-photo.png'\n    )\n</code></pre>"},{"location":"advanced/#using-iobytesio","title":"Using io.BytesIO","text":"<p>You can also use in-memory file objects:</p> <pre><code>import io\nimport pynetbox\n\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n)\n\n# Create image from bytes\nimage_data = b'...'  # Your image bytes\nfile_obj = io.BytesIO(image_data)\nfile_obj.name = 'generated-image.png'  # Optional: set filename\n\nattachment = nb.extras.image_attachments.create(\n    object_type='dcim.device',\n    object_id=1,\n    image=file_obj\n)\n</code></pre>"},{"location":"advanced/#custom-filename-and-content-type","title":"Custom Filename and Content-Type","text":"<p>For more control, pass a tuple instead of a file object:</p> <pre><code>with open('/path/to/image.png', 'rb') as f:\n    attachment = nb.extras.image_attachments.create(\n        object_type='dcim.device',\n        object_id=1,\n        image=('custom-name.png', f, 'image/png')\n    )\n</code></pre> <p>The tuple format is <code>(filename, file_object)</code> or <code>(filename, file_object, content_type)</code>.</p>"},{"location":"advanced/#multi-format-responses","title":"Multi-Format Responses","text":"<p>Some endpoints support multiple response formats. The rack elevation endpoint can return both JSON data and SVG diagrams.</p>"},{"location":"advanced/#getting-rack-elevation-as-json","title":"Getting Rack Elevation as JSON","text":"<p>By default, the elevation endpoint returns JSON data as a list of rack unit objects:</p> <pre><code>import pynetbox\n\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n)\n\nrack = nb.dcim.racks.get(123)\n\n# Returns list of RU objects (default JSON response)\nunits = rack.elevation.list()\nfor unit in units:\n    print(unit.id, unit.name)\n</code></pre>"},{"location":"advanced/#getting-rack-elevation-as-svg","title":"Getting Rack Elevation as SVG","text":"<p>Use the <code>render='svg'</code> parameter to get a graphical SVG diagram:</p> <pre><code>rack = nb.dcim.racks.get(123)\n\n# Returns raw SVG string\nsvg_diagram = rack.elevation.list(render='svg')\nprint(svg_diagram)  # '&lt;svg xmlns=\"http://www.w3.org/2000/svg\"&gt;...&lt;/svg&gt;'\n\n# Save to file\nwith open('rack-elevation.svg', 'w') as f:\n    f.write(svg_diagram)\n</code></pre>"},{"location":"api/","title":"API Core Classes","text":"<p>This page documents the core classes that form pyNetBox's API structure.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>PyNetBox uses a layered architecture to interact with NetBox:</p> <ol> <li>Api - The main entry point that creates connections to NetBox</li> <li>App - Represents NetBox applications (dcim, ipam, circuits, etc.)</li> <li>Endpoint - Provides CRUD operations for specific API endpoints</li> </ol> <pre><code>import pynetbox\n\n# Create API connection (Api class)\nnb = pynetbox.api('http://localhost:8000', token='your-token')\n\n# Access an app (App class)\nnb.dcim  # Returns an App instance\n\n# Access an endpoint (Endpoint class)\nnb.dcim.devices  # Returns an Endpoint instance\n\n# Use endpoint methods\ndevices = nb.dcim.devices.all()\n</code></pre>"},{"location":"api/#api-class","title":"Api Class","text":"<p>The <code>Api</code> class is the main entry point for interacting with NetBox. It manages the HTTP session, authentication, and provides access to NetBox applications.</p>"},{"location":"api/#pynetbox.core.api.Api","title":"<code> pynetbox.core.api.Api        </code>","text":"<p>The API object is the point of entry to pynetbox.</p> <p>After instantiating the Api() with the appropriate named arguments you can specify which app and endpoint you wish to interact with.</p> <p>Valid attributes currently are:</p> <ul> <li>circuits</li> <li>core (NetBox 3.5+)</li> <li>dcim</li> <li>extras</li> <li>ipam</li> <li>tenancy</li> <li>users</li> <li>virtualization</li> <li>vpn (NetBox 3.7+)</li> <li>wireless</li> </ul> <p>Calling any of these attributes will return an <code>App</code> object which exposes endpoints as attributes.</p>"},{"location":"api/#pynetbox.core.api.Api--additional-attributes","title":"Additional Attributes","text":"<ul> <li>http_session(requests.Session): Override the default session with your own. This is used to control   a number of HTTP behaviors such as SSL verification, custom headers,   retires, and timeouts.   See custom sessions for more info.</li> </ul>"},{"location":"api/#pynetbox.core.api.Api--parameters","title":"Parameters","text":"<ul> <li>url (str): The base URL to the instance of NetBox you wish to connect to.</li> <li>token (str): Your NetBox token.</li> <li>threading (bool, optional): Set to True to use threading in <code>.all()</code> and <code>.filter()</code> requests.</li> </ul>"},{"location":"api/#pynetbox.core.api.Api--raises","title":"Raises","text":"<ul> <li>AttributeError: If app doesn't exist.</li> </ul>"},{"location":"api/#pynetbox.core.api.Api--examples","title":"Examples","text":"<pre><code>import pynetbox\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n)\nlist(nb.dcim.devices.all())\n# [test1-leaf1, test1-leaf2, test1-leaf3]\n</code></pre> Source code in <code>pynetbox/core/api.py</code> <pre><code>class Api:\n    \"\"\"The API object is the point of entry to pynetbox.\n\n    After instantiating the Api() with the appropriate named arguments\n    you can specify which app and endpoint you wish to interact with.\n\n    Valid attributes currently are:\n\n    * circuits\n    * core (NetBox 3.5+)\n    * dcim\n    * extras\n    * ipam\n    * tenancy\n    * users\n    * virtualization\n    * vpn (NetBox 3.7+)\n    * wireless\n\n    Calling any of these attributes will return an `App` object which exposes endpoints as attributes.\n\n    ## Additional Attributes\n\n    * **http_session(requests.Session)**: Override the default session with your own. This is used to control\n      a number of HTTP behaviors such as SSL verification, custom headers,\n      retires, and timeouts.\n      See [custom sessions](advanced.md#custom-sessions) for more info.\n\n    ## Parameters\n\n    * **url** (str): The base URL to the instance of NetBox you wish to connect to.\n    * **token** (str): Your NetBox token.\n    * **threading** (bool, optional): Set to True to use threading in `.all()` and `.filter()` requests.\n\n    ## Raises\n\n    * **AttributeError**: If app doesn't exist.\n\n    ## Examples\n\n    ```python\n    import pynetbox\n    nb = pynetbox.api(\n        'http://localhost:8000',\n        token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n    )\n    list(nb.dcim.devices.all())\n    # [test1-leaf1, test1-leaf2, test1-leaf3]\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        url,\n        token=None,\n        threading=False,\n        strict_filters=False,\n    ):\n        \"\"\"Initialize the API client.\n\n        Args:\n            url (str): The base URL to the instance of NetBox you wish to connect to.\n            token (str, optional): Your NetBox API token. If not provided, authentication will be required for each request.\n            threading (bool, optional): Set to True to use threading in `.all()` and `.filter()` requests, defaults to False.\n            strict_filters (bool, optional): Set to True to check GET call filters against OpenAPI specifications (intentionally not done in NetBox API), defaults to False.\n        \"\"\"\n        base_url = \"{}/api\".format(url if url[-1] != \"/\" else url[:-1])\n        self.token = token\n        self.base_url = base_url\n        self.http_session = requests.Session()\n        self.threading = threading\n        self.strict_filters = strict_filters\n\n        # Initialize NetBox apps\n        self.circuits = App(self, \"circuits\")\n        self.core = App(self, \"core\")\n        self.dcim = App(self, \"dcim\")\n        self.extras = App(self, \"extras\")\n        self.ipam = App(self, \"ipam\")\n        self.tenancy = App(self, \"tenancy\")\n        self.users = App(self, \"users\")\n        self.virtualization = App(self, \"virtualization\")\n        self.vpn = App(self, \"vpn\")\n        self.wireless = App(self, \"wireless\")\n        self.plugins = PluginsApp(self)\n\n    @property\n    def version(self):\n        \"\"\"Gets the API version of NetBox.\n\n        Can be used to check the NetBox API version if there are\n        version-dependent features or syntaxes in the API.\n\n        ## Returns\n        Version number as a string.\n\n        ## Example\n\n        ```python\n        import pynetbox\n        nb = pynetbox.api(\n            'http://localhost:8000',\n            token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n        )\n        nb.version\n        # '3.1'\n        ```\n        \"\"\"\n        version = Request(\n            base=self.base_url,\n            token=self.token,\n            http_session=self.http_session,\n        ).get_version()\n        return version\n\n    def openapi(self):\n        \"\"\"Returns the OpenAPI spec.\n\n        Quick helper function to pull down the entire OpenAPI spec.\n        It is stored in memory to avoid repeated calls on NetBox API.\n\n        ## Returns\n        dict: The OpenAPI specification as a dictionary.\n\n        ## Example\n\n        ```python\n        import pynetbox\n        nb = pynetbox.api(\n            'http://localhost:8000',\n            token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n        )\n        nb.openapi()\n        # {...}\n        ```\n        \"\"\"\n        if not (openapi := getattr(self, \"_openapi\", None)):\n            openapi = self._openapi = Request(\n                base=self.base_url,\n                http_session=self.http_session,\n            ).get_openapi()\n\n        return openapi\n\n    def status(self):\n        \"\"\"Gets the status information from NetBox.\n\n        ## Returns\n        Dictionary containing NetBox status information.\n\n        ## Raises\n        `RequestError`: If the request is not successful.\n\n        ## Example\n\n        ```python\n        from pprint import pprint\n        pprint(nb.status())\n        {\n            'django-version': '3.1.3',\n            'installed-apps': {\n                'cacheops': '5.0.1',\n                'debug_toolbar': '3.1.1',\n                'django_filters': '2.4.0',\n                'django_prometheus': '2.1.0',\n                'django_rq': '2.4.0',\n                'django_tables2': '2.3.3',\n                'drf_yasg': '1.20.0',\n                'mptt': '0.11.0',\n                'rest_framework': '3.12.2',\n                'taggit': '1.3.0',\n                'timezone_field': '4.0'\n            },\n            'netbox-version': '2.10.2',\n            'plugins': {},\n            'python-version': '3.7.3',\n            'rq-workers-running': 1\n        }\n        ```\n        \"\"\"\n        status = Request(\n            base=self.base_url,\n            token=self.token,\n            http_session=self.http_session,\n        ).get_status()\n        return status\n\n    def create_token(self, username, password):\n        \"\"\"Creates an API token using a valid NetBox username and password.\n        Saves the created token automatically in the API object.\n\n        ## Parameters\n        * **username** (str): NetBox username\n        * **password** (str): NetBox password\n\n        ## Returns\n        `Record`: The token as a Record object.\n\n        ## Raises\n        `RequestError`: If the request is not successful.\n\n        ## Example\n\n        ```python\n        import pynetbox\n        nb = pynetbox.api(\"https://netbox-server\")\n        token = nb.create_token(\"admin\", \"netboxpassword\")\n        nb.token\n        # '96d02e13e3f1fdcd8b4c089094c0191dcb045bef'\n\n        from pprint import pprint\n        pprint(dict(token))\n        {\n            'created': '2021-11-27T11:26:49.360185+02:00',\n            'description': '',\n            'display': '045bef (admin)',\n            'expires': None,\n            'id': 2,\n            'key': '96d02e13e3f1fdcd8b4c089094c0191dcb045bef',\n            'url': 'https://netbox-server/api/users/tokens/2/',\n            'user': {\n                'display': 'admin',\n                'id': 1,\n                'url': 'https://netbox-server/api/users/users/1/',\n                'username': 'admin'\n            },\n            'write_enabled': True\n        }\n        ```\n        \"\"\"\n        resp = Request(\n            base=\"{}/users/tokens/provision/\".format(self.base_url),\n            http_session=self.http_session,\n        ).post(data={\"username\": username, \"password\": password})\n        # Save the newly created API token, otherwise populating the Record\n        # object details will fail\n        self.token = resp[\"key\"]\n        return Record(resp, self, None)\n\n    @contextlib.contextmanager\n    def activate_branch(self, branch):\n        \"\"\"Context manager to activate the branch by setting the schema ID in the headers.\n\n        **Note**: The NetBox branching plugin must be installed and enabled in your NetBox instance for this functionality to work.\n\n        ## Parameters\n        * **branch** (Record): The NetBox branch to activate\n\n        ## Raises\n        `ValueError`: If the branch is not a valid NetBox branch.\n\n        ## Example\n\n        ```python\n        import pynetbox\n        nb = pynetbox.api(\"https://netbox-server\")\n        branch = nb.plugins.branching.branches.create(name=\"testbranch\")\n        with nb.activate_branch(branch):\n            sites = nb.dcim.sites.all()\n            # All operations within this block will use the branch's schema\n        ```\n        \"\"\"\n        if not isinstance(branch, Record) or \"schema_id\" not in dict(branch):\n            raise ValueError(\n                f\"The specified branch is not a valid NetBox branch: {branch}.\"\n            )\n\n        self.http_session.headers[\"X-NetBox-Branch\"] = branch.schema_id\n\n        try:\n            yield\n        finally:\n            self.http_session.headers.pop(\"X-NetBox-Branch\", None)\n</code></pre>"},{"location":"api/#pynetbox.core.api.Api.version","title":"<code>version</code>  <code>property</code> <code>readonly</code>","text":"<p>Gets the API version of NetBox.</p> <p>Can be used to check the NetBox API version if there are version-dependent features or syntaxes in the API.</p>"},{"location":"api/#pynetbox.core.api.Api.version--returns","title":"Returns","text":"<p>Version number as a string.</p>"},{"location":"api/#pynetbox.core.api.Api.version--example","title":"Example","text":"<pre><code>import pynetbox\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n)\nnb.version\n# '3.1'\n</code></pre>"},{"location":"api/#pynetbox.core.api.Api.__init__","title":"<code>__init__(self, url, token=None, threading=False, strict_filters=False)</code>  <code>special</code>","text":"<p>Initialize the API client.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The base URL to the instance of NetBox you wish to connect to.</p> required <code>token</code> <code>str</code> <p>Your NetBox API token. If not provided, authentication will be required for each request.</p> <code>None</code> <code>threading</code> <code>bool</code> <p>Set to True to use threading in <code>.all()</code> and <code>.filter()</code> requests, defaults to False.</p> <code>False</code> <code>strict_filters</code> <code>bool</code> <p>Set to True to check GET call filters against OpenAPI specifications (intentionally not done in NetBox API), defaults to False.</p> <code>False</code> Source code in <code>pynetbox/core/api.py</code> <pre><code>def __init__(\n    self,\n    url,\n    token=None,\n    threading=False,\n    strict_filters=False,\n):\n    \"\"\"Initialize the API client.\n\n    Args:\n        url (str): The base URL to the instance of NetBox you wish to connect to.\n        token (str, optional): Your NetBox API token. If not provided, authentication will be required for each request.\n        threading (bool, optional): Set to True to use threading in `.all()` and `.filter()` requests, defaults to False.\n        strict_filters (bool, optional): Set to True to check GET call filters against OpenAPI specifications (intentionally not done in NetBox API), defaults to False.\n    \"\"\"\n    base_url = \"{}/api\".format(url if url[-1] != \"/\" else url[:-1])\n    self.token = token\n    self.base_url = base_url\n    self.http_session = requests.Session()\n    self.threading = threading\n    self.strict_filters = strict_filters\n\n    # Initialize NetBox apps\n    self.circuits = App(self, \"circuits\")\n    self.core = App(self, \"core\")\n    self.dcim = App(self, \"dcim\")\n    self.extras = App(self, \"extras\")\n    self.ipam = App(self, \"ipam\")\n    self.tenancy = App(self, \"tenancy\")\n    self.users = App(self, \"users\")\n    self.virtualization = App(self, \"virtualization\")\n    self.vpn = App(self, \"vpn\")\n    self.wireless = App(self, \"wireless\")\n    self.plugins = PluginsApp(self)\n</code></pre>"},{"location":"api/#pynetbox.core.api.Api.activate_branch","title":"<code>activate_branch(self, branch)</code>","text":"<p>Context manager to activate the branch by setting the schema ID in the headers.</p> <p>Note: The NetBox branching plugin must be installed and enabled in your NetBox instance for this functionality to work.</p>"},{"location":"api/#pynetbox.core.api.Api.activate_branch--parameters","title":"Parameters","text":"<ul> <li>branch (Record): The NetBox branch to activate</li> </ul>"},{"location":"api/#pynetbox.core.api.Api.activate_branch--raises","title":"Raises","text":"<p><code>ValueError</code>: If the branch is not a valid NetBox branch.</p>"},{"location":"api/#pynetbox.core.api.Api.activate_branch--example","title":"Example","text":"<pre><code>import pynetbox\nnb = pynetbox.api(\"https://netbox-server\")\nbranch = nb.plugins.branching.branches.create(name=\"testbranch\")\nwith nb.activate_branch(branch):\n    sites = nb.dcim.sites.all()\n    # All operations within this block will use the branch's schema\n</code></pre> Source code in <code>pynetbox/core/api.py</code> <pre><code>@contextlib.contextmanager\ndef activate_branch(self, branch):\n    \"\"\"Context manager to activate the branch by setting the schema ID in the headers.\n\n    **Note**: The NetBox branching plugin must be installed and enabled in your NetBox instance for this functionality to work.\n\n    ## Parameters\n    * **branch** (Record): The NetBox branch to activate\n\n    ## Raises\n    `ValueError`: If the branch is not a valid NetBox branch.\n\n    ## Example\n\n    ```python\n    import pynetbox\n    nb = pynetbox.api(\"https://netbox-server\")\n    branch = nb.plugins.branching.branches.create(name=\"testbranch\")\n    with nb.activate_branch(branch):\n        sites = nb.dcim.sites.all()\n        # All operations within this block will use the branch's schema\n    ```\n    \"\"\"\n    if not isinstance(branch, Record) or \"schema_id\" not in dict(branch):\n        raise ValueError(\n            f\"The specified branch is not a valid NetBox branch: {branch}.\"\n        )\n\n    self.http_session.headers[\"X-NetBox-Branch\"] = branch.schema_id\n\n    try:\n        yield\n    finally:\n        self.http_session.headers.pop(\"X-NetBox-Branch\", None)\n</code></pre>"},{"location":"api/#pynetbox.core.api.Api.create_token","title":"<code>create_token(self, username, password)</code>","text":"<p>Creates an API token using a valid NetBox username and password. Saves the created token automatically in the API object.</p>"},{"location":"api/#pynetbox.core.api.Api.create_token--parameters","title":"Parameters","text":"<ul> <li>username (str): NetBox username</li> <li>password (str): NetBox password</li> </ul>"},{"location":"api/#pynetbox.core.api.Api.create_token--returns","title":"Returns","text":"<p><code>Record</code>: The token as a Record object.</p>"},{"location":"api/#pynetbox.core.api.Api.create_token--raises","title":"Raises","text":"<p><code>RequestError</code>: If the request is not successful.</p>"},{"location":"api/#pynetbox.core.api.Api.create_token--example","title":"Example","text":"<pre><code>import pynetbox\nnb = pynetbox.api(\"https://netbox-server\")\ntoken = nb.create_token(\"admin\", \"netboxpassword\")\nnb.token\n# '96d02e13e3f1fdcd8b4c089094c0191dcb045bef'\n\nfrom pprint import pprint\npprint(dict(token))\n{\n    'created': '2021-11-27T11:26:49.360185+02:00',\n    'description': '',\n    'display': '045bef (admin)',\n    'expires': None,\n    'id': 2,\n    'key': '96d02e13e3f1fdcd8b4c089094c0191dcb045bef',\n    'url': 'https://netbox-server/api/users/tokens/2/',\n    'user': {\n        'display': 'admin',\n        'id': 1,\n        'url': 'https://netbox-server/api/users/users/1/',\n        'username': 'admin'\n    },\n    'write_enabled': True\n}\n</code></pre> Source code in <code>pynetbox/core/api.py</code> <pre><code>def create_token(self, username, password):\n    \"\"\"Creates an API token using a valid NetBox username and password.\n    Saves the created token automatically in the API object.\n\n    ## Parameters\n    * **username** (str): NetBox username\n    * **password** (str): NetBox password\n\n    ## Returns\n    `Record`: The token as a Record object.\n\n    ## Raises\n    `RequestError`: If the request is not successful.\n\n    ## Example\n\n    ```python\n    import pynetbox\n    nb = pynetbox.api(\"https://netbox-server\")\n    token = nb.create_token(\"admin\", \"netboxpassword\")\n    nb.token\n    # '96d02e13e3f1fdcd8b4c089094c0191dcb045bef'\n\n    from pprint import pprint\n    pprint(dict(token))\n    {\n        'created': '2021-11-27T11:26:49.360185+02:00',\n        'description': '',\n        'display': '045bef (admin)',\n        'expires': None,\n        'id': 2,\n        'key': '96d02e13e3f1fdcd8b4c089094c0191dcb045bef',\n        'url': 'https://netbox-server/api/users/tokens/2/',\n        'user': {\n            'display': 'admin',\n            'id': 1,\n            'url': 'https://netbox-server/api/users/users/1/',\n            'username': 'admin'\n        },\n        'write_enabled': True\n    }\n    ```\n    \"\"\"\n    resp = Request(\n        base=\"{}/users/tokens/provision/\".format(self.base_url),\n        http_session=self.http_session,\n    ).post(data={\"username\": username, \"password\": password})\n    # Save the newly created API token, otherwise populating the Record\n    # object details will fail\n    self.token = resp[\"key\"]\n    return Record(resp, self, None)\n</code></pre>"},{"location":"api/#pynetbox.core.api.Api.openapi","title":"<code>openapi(self)</code>","text":"<p>Returns the OpenAPI spec.</p> <p>Quick helper function to pull down the entire OpenAPI spec. It is stored in memory to avoid repeated calls on NetBox API.</p>"},{"location":"api/#pynetbox.core.api.Api.openapi--returns","title":"Returns","text":"<p>dict: The OpenAPI specification as a dictionary.</p>"},{"location":"api/#pynetbox.core.api.Api.openapi--example","title":"Example","text":"<pre><code>import pynetbox\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n)\nnb.openapi()\n# {...}\n</code></pre> Source code in <code>pynetbox/core/api.py</code> <pre><code>def openapi(self):\n    \"\"\"Returns the OpenAPI spec.\n\n    Quick helper function to pull down the entire OpenAPI spec.\n    It is stored in memory to avoid repeated calls on NetBox API.\n\n    ## Returns\n    dict: The OpenAPI specification as a dictionary.\n\n    ## Example\n\n    ```python\n    import pynetbox\n    nb = pynetbox.api(\n        'http://localhost:8000',\n        token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n    )\n    nb.openapi()\n    # {...}\n    ```\n    \"\"\"\n    if not (openapi := getattr(self, \"_openapi\", None)):\n        openapi = self._openapi = Request(\n            base=self.base_url,\n            http_session=self.http_session,\n        ).get_openapi()\n\n    return openapi\n</code></pre>"},{"location":"api/#pynetbox.core.api.Api.status","title":"<code>status(self)</code>","text":"<p>Gets the status information from NetBox.</p>"},{"location":"api/#pynetbox.core.api.Api.status--returns","title":"Returns","text":"<p>Dictionary containing NetBox status information.</p>"},{"location":"api/#pynetbox.core.api.Api.status--raises","title":"Raises","text":"<p><code>RequestError</code>: If the request is not successful.</p>"},{"location":"api/#pynetbox.core.api.Api.status--example","title":"Example","text":"<pre><code>from pprint import pprint\npprint(nb.status())\n{\n    'django-version': '3.1.3',\n    'installed-apps': {\n        'cacheops': '5.0.1',\n        'debug_toolbar': '3.1.1',\n        'django_filters': '2.4.0',\n        'django_prometheus': '2.1.0',\n        'django_rq': '2.4.0',\n        'django_tables2': '2.3.3',\n        'drf_yasg': '1.20.0',\n        'mptt': '0.11.0',\n        'rest_framework': '3.12.2',\n        'taggit': '1.3.0',\n        'timezone_field': '4.0'\n    },\n    'netbox-version': '2.10.2',\n    'plugins': {},\n    'python-version': '3.7.3',\n    'rq-workers-running': 1\n}\n</code></pre> Source code in <code>pynetbox/core/api.py</code> <pre><code>def status(self):\n    \"\"\"Gets the status information from NetBox.\n\n    ## Returns\n    Dictionary containing NetBox status information.\n\n    ## Raises\n    `RequestError`: If the request is not successful.\n\n    ## Example\n\n    ```python\n    from pprint import pprint\n    pprint(nb.status())\n    {\n        'django-version': '3.1.3',\n        'installed-apps': {\n            'cacheops': '5.0.1',\n            'debug_toolbar': '3.1.1',\n            'django_filters': '2.4.0',\n            'django_prometheus': '2.1.0',\n            'django_rq': '2.4.0',\n            'django_tables2': '2.3.3',\n            'drf_yasg': '1.20.0',\n            'mptt': '0.11.0',\n            'rest_framework': '3.12.2',\n            'taggit': '1.3.0',\n            'timezone_field': '4.0'\n        },\n        'netbox-version': '2.10.2',\n        'plugins': {},\n        'python-version': '3.7.3',\n        'rq-workers-running': 1\n    }\n    ```\n    \"\"\"\n    status = Request(\n        base=self.base_url,\n        token=self.token,\n        http_session=self.http_session,\n    ).get_status()\n    return status\n</code></pre>"},{"location":"api/#app-class","title":"App Class","text":"<p>The <code>App</code> class represents a NetBox application (such as dcim, ipam, circuits). When you access an attribute on the <code>Api</code> object, it returns an <code>App</code> instance. Accessing attributes on an <code>App</code> returns <code>Endpoint</code> objects.</p>"},{"location":"api/#pynetbox.core.app.App","title":"<code> pynetbox.core.app.App        </code>","text":"<p>Represents apps in NetBox.</p> <p>Calls to attributes are returned as Endpoint objects.</p>"},{"location":"api/#pynetbox.core.app.App--returns","title":"Returns","text":"<p>Endpoint matching requested attribute.</p>"},{"location":"api/#pynetbox.core.app.App--raises","title":"Raises","text":"<p>RequestError if requested endpoint doesn't exist.</p> Source code in <code>pynetbox/core/app.py</code> <pre><code>class App:\n    \"\"\"Represents apps in NetBox.\n\n    Calls to attributes are returned as Endpoint objects.\n\n    ## Returns\n    Endpoint matching requested attribute.\n\n    ## Raises\n    RequestError if requested endpoint doesn't exist.\n    \"\"\"\n\n    def __init__(self, api, name):\n        self.api = api\n        self.name = name\n        self._setmodel()\n\n    models = {\n        \"circuits\": circuits,\n        \"core\": core,\n        \"dcim\": dcim,\n        \"extras\": extras,\n        \"ipam\": ipam,\n        \"users\": users,\n        \"virtualization\": virtualization,\n        \"wireless\": wireless,\n    }\n\n    def _setmodel(self):\n        self.model = App.models[self.name] if self.name in App.models else None\n\n    def __getstate__(self):\n        return {\"api\": self.api, \"name\": self.name}\n\n    def __setstate__(self, d):\n        self.__dict__.update(d)\n        self._setmodel()\n\n    def __getattr__(self, name):\n        return Endpoint(self.api, self, name, model=self.model)\n\n    def config(self):\n        \"\"\"Returns config response from app.\n\n        ## Returns\n        Raw response from NetBox's config endpoint.\n\n        ## Raises\n        RequestError if called for an invalid endpoint.\n\n        ## Examples\n\n        ```python\n        pprint.pprint(nb.users.config())\n        {\n            'tables': {\n                'DeviceTable': {\n                    'columns': [\n                        'name',\n                        'status',\n                        'tenant',\n                        'role',\n                        'site',\n                        'primary_ip',\n                        'tags'\n                    ]\n                }\n            }\n        }\n        ```\n        \"\"\"\n        config = Request(\n            base=\"{}/{}/config/\".format(\n                self.api.base_url,\n                self.name,\n            ),\n            token=self.api.token,\n            http_session=self.api.http_session,\n        ).get()\n        return config\n</code></pre>"},{"location":"api/#pynetbox.core.app.App.config","title":"<code>config(self)</code>","text":"<p>Returns config response from app.</p>"},{"location":"api/#pynetbox.core.app.App.config--returns","title":"Returns","text":"<p>Raw response from NetBox's config endpoint.</p>"},{"location":"api/#pynetbox.core.app.App.config--raises","title":"Raises","text":"<p>RequestError if called for an invalid endpoint.</p>"},{"location":"api/#pynetbox.core.app.App.config--examples","title":"Examples","text":"<pre><code>pprint.pprint(nb.users.config())\n{\n    'tables': {\n        'DeviceTable': {\n            'columns': [\n                'name',\n                'status',\n                'tenant',\n                'role',\n                'site',\n                'primary_ip',\n                'tags'\n            ]\n        }\n    }\n}\n</code></pre> Source code in <code>pynetbox/core/app.py</code> <pre><code>def config(self):\n    \"\"\"Returns config response from app.\n\n    ## Returns\n    Raw response from NetBox's config endpoint.\n\n    ## Raises\n    RequestError if called for an invalid endpoint.\n\n    ## Examples\n\n    ```python\n    pprint.pprint(nb.users.config())\n    {\n        'tables': {\n            'DeviceTable': {\n                'columns': [\n                    'name',\n                    'status',\n                    'tenant',\n                    'role',\n                    'site',\n                    'primary_ip',\n                    'tags'\n                ]\n            }\n        }\n    }\n    ```\n    \"\"\"\n    config = Request(\n        base=\"{}/{}/config/\".format(\n            self.api.base_url,\n            self.name,\n        ),\n        token=self.api.token,\n        http_session=self.api.http_session,\n    ).get()\n    return config\n</code></pre>"},{"location":"api/#relationship-to-endpoints","title":"Relationship to Endpoints","text":"<p>When you access an attribute on an <code>App</code> object, it returns an Endpoint instance:</p> <pre><code># nb.dcim is an App instance\n# nb.dcim.devices is an Endpoint instance\ndevices_endpoint = nb.dcim.devices\n\n# Endpoint provides CRUD methods\nall_devices = devices_endpoint.all()\ndevice = devices_endpoint.get(1)\nnew_device = devices_endpoint.create(name='test', site=1, device_type=1, device_role=1)\n</code></pre> <p>See the Endpoint documentation for details on available methods.</p>"},{"location":"branching/","title":"Branching Plugin","text":"<p>The NetBox branching plugin allows you to create and work with branches in NetBox, similar to version control systems. This enables you to make changes in isolation and merge them back to the main branch when ready.</p>"},{"location":"branching/#activating-branches","title":"Activating Branches","text":"<p>The <code>activate_branch</code> context manager allows you to perform operations within a specific branch's schema. All operations performed within the context manager will use that branch's schema.</p> <pre><code>import pynetbox\n\n# Initialize the API\nnb = pynetbox.api(\n    \"http://localhost:8000\",\n    token=\"your-token-here\"\n)\n\n# Get an existing branch\nbranch = nb.plugins.branching.branches.get(id=1)\n\n# Activate the branch for operations\nwith nb.activate_branch(branch):\n    # All operations within this block will use the branch's schema\n    sites = nb.dcim.sites.all()\n    # Make changes to objects...\n    # These changes will only exist in this branch\n</code></pre>"},{"location":"branching/#waiting-for-branch-status","title":"Waiting for Branch Status","text":"<p>When working with branches, you often need to wait for certain status changes, such as when a branch becomes ready after creation or when a merge operation completes. The tenacity library provides a robust way to handle these waiting scenarios.</p> <p>First, install tenacity:</p> <pre><code>pip install tenacity\n</code></pre> <p>Here's how to create a reusable function to wait for branch status changes:</p> <pre><code>from tenacity import retry, retry_if_result, stop_after_attempt, wait_exponential\nimport pynetbox\n\n@retry(\n    stop=stop_after_attempt(30),  # Try for up to 30 attempts\n    wait=wait_exponential(\n        multiplier=1, min=4, max=60\n    ),  # Wait between 4-60 seconds, increasing exponentially\n    retry=retry_if_result(lambda x: not x),  # Retry if the status check returns False\n)\ndef wait_for_branch_status(branch, target_status):\n    \"\"\"Wait for branch to reach a specific status, with exponential backoff.\"\"\"\n    branch = nb.plugins.branching.branches.get(branch.id)\n    return str(branch.status) == target_status\n\n# Example usage:\nbranch = nb.plugins.branching.branches.create(name=\"my-branch\")\n\n# Wait for branch to be ready\nwait_for_branch_status(branch, \"Ready\")\n\n# Get the latest branch status\nbranch = nb.plugins.branching.branches.get(branch.id)\nprint(f\"Branch is now ready! Status: {branch.status}\")\n</code></pre> <p>The function will:</p> <ol> <li>Check the current status of the branch</li> <li>If the status doesn't match the target status, it will retry with exponential backoff</li> <li>Continue retrying until either:<ul> <li>The branch reaches the target status</li> <li>The maximum number of attempts (30) is reached</li> <li>The maximum wait time (60 seconds) is exceeded</li> </ul> </li> </ol> <p>The exponential backoff ensures that we don't overwhelm the server with requests while still checking frequently enough to catch status changes quickly. </p>"},{"location":"circuits/","title":"Circuits","text":"<p>This page documents special methods available for Circuits models in pyNetBox.</p> <p>Standard API Operations</p> <p>Standard CRUD operations (<code>.all()</code>, <code>.filter()</code>, <code>.get()</code>, <code>.create()</code>, <code>.update()</code>, <code>.delete()</code>) follow NetBox's REST API patterns. Refer to the NetBox API documentation for details on available endpoints and filters.</p>"},{"location":"circuits/#circuit-terminations","title":"Circuit Terminations","text":""},{"location":"circuits/#cable-path-tracing","title":"Cable Path Tracing","text":"<p>Circuit terminations support cable path tracing through the <code>paths()</code> method. This method returns all cable paths that traverse through the circuit termination, showing the complete connectivity from origin to destination.</p> <p>Example: <pre><code># Get a circuit termination\ncircuit_term = nb.circuits.circuit_terminations.get(circuit_id=123, term_side='A')\n\n# Get all cable paths through this termination\npaths = circuit_term.paths()\n\n# Each path contains origin, destination, and path segments\nfor path_info in paths:\n    print(f\"Origin: {path_info['origin']}\")\n    print(f\"Destination: {path_info['destination']}\")\n    print(\"Path segments:\")\n    for segment in path_info['path']:\n        for obj in segment:\n            print(f\"  - {obj}\")\n\n# Example: Find what a circuit connects to\ncircuit = nb.circuits.circuits.get(cid='CIRCUIT-001')\nterminations = nb.circuits.circuit_terminations.filter(circuit_id=circuit.id)\n\nfor term in terminations:\n    print(f\"\\nTermination {term.term_side}:\")\n    paths = term.paths()\n    if paths:\n        for path in paths:\n            if path['destination']:\n                print(f\"  Connected to: {path['destination']}\")\n            else:\n                print(\"  No destination (incomplete path)\")\n    else:\n        print(\"  No cable paths\")\n</code></pre></p> <p>Path Structure:</p> <p>The <code>paths()</code> method returns a list of dictionaries, where each dictionary represents a complete cable path:</p> <ul> <li><code>origin</code>: The starting endpoint of the path (Record object or None if unconnected)</li> <li><code>destination</code>: The ending endpoint of the path (Record object or None if unconnected)</li> <li><code>path</code>: A list of path segments, where each segment is a list of Record objects representing the components in that segment (cables, terminations, interfaces, etc.)</li> </ul>"},{"location":"circuits/#virtual-circuits","title":"Virtual Circuits","text":""},{"location":"circuits/#overview","title":"Overview","text":"<p>Virtual circuits also support cable path tracing through the <code>paths()</code> method.</p> <p>Example: <pre><code># Get a virtual circuit\nvcircuit = nb.circuits.virtual_circuits.get(cid='VPLS-001')\nprint(f\"Virtual Circuit: {vcircuit.cid}\")\nprint(f\"Provider Network: {vcircuit.provider_network.name}\")\nprint(f\"Type: {vcircuit.type.name}\")\n\n# List all terminations for a virtual circuit\nterminations = nb.circuits.virtual_circuit_terminations.filter(\n    virtual_circuit_id=vcircuit.id\n)\nfor term in terminations:\n    print(f\"Termination Role: {term.role}\")\n</code></pre></p>"},{"location":"circuits/#virtual-circuit-termination-path-tracing","title":"Virtual Circuit Termination Path Tracing","text":"<p>Virtual circuit terminations also support cable path tracing through the <code>paths()</code> method.</p> <p>Example: <pre><code># Get a virtual circuit termination\nvterm = nb.circuits.virtual_circuit_terminations.get(\n    virtual_circuit_id=123, role='hub'\n)\n\n# Get all cable paths through this termination\npaths = vterm.paths()\n\n# Analyze the connectivity\nfor path_info in paths:\n    print(f\"Origin: {path_info['origin']}\")\n    print(f\"Destination: {path_info['destination']}\")\n    print(\"Path segments:\")\n    for segment in path_info['path']:\n        for obj in segment:\n            print(f\"  - {obj}\")\n\n# Example: Find all devices connected via a virtual circuit\nvcircuit = nb.circuits.virtual_circuits.get(cid='VPLS-001')\nterminations = nb.circuits.virtual_circuit_terminations.filter(\n    virtual_circuit_id=vcircuit.id\n)\n\nprint(f\"Virtual Circuit {vcircuit.cid} connectivity:\")\nfor term in terminations:\n    paths = term.paths()\n    if paths and paths[0]['destination']:\n        print(f\"  {term.role}: {paths[0]['destination']}\")\n</code></pre></p>"},{"location":"dcim/","title":"DCIM","text":"<p>This page documents special methods available for DCIM models in pyNetBox.</p> <p>Standard API Operations</p> <p>Standard CRUD operations (<code>.all()</code>, <code>.filter()</code>, <code>.get()</code>, <code>.create()</code>, <code>.update()</code>, <code>.delete()</code>) follow NetBox's REST API patterns. Refer to the NetBox API documentation for details on available endpoints and filters.</p>"},{"location":"dcim/#devices","title":"Devices","text":""},{"location":"dcim/#napalm-integration","title":"NAPALM Integration","text":"<p>The <code>napalm</code> property provides access to NAPALM device data.</p> <p>Example: <pre><code>device = nb.dcim.devices.get(name='router1')\n\n# Get device facts\nfacts = device.napalm.list(method='get_facts')\nprint(facts)\n\n# Get interfaces\ninterfaces = device.napalm.list(method='get_interfaces')\n\n# Get ARP table\narp = device.napalm.list(method='get_arp_table')\n</code></pre></p>"},{"location":"dcim/#pynetbox.models.dcim.Devices.napalm","title":"<code>pynetbox.models.dcim.Devices.napalm</code>  <code>property</code> <code>readonly</code>","text":"<p>Represents the <code>napalm</code> detail endpoint.</p> <p>Returns a DetailEndpoint object that is the interface for viewing response from the napalm endpoint.</p>"},{"location":"dcim/#pynetbox.models.dcim.Devices.napalm--returns","title":"Returns","text":"<p>DetailEndpoint object.</p>"},{"location":"dcim/#pynetbox.models.dcim.Devices.napalm--examples","title":"Examples","text":"<pre><code>device = nb.ipam.devices.get(123)\ndevice.napalm.list(method='get_facts')\n# {\"get_facts\": {\"interface_list\": [\"ge-0/0/0\"]}}\n</code></pre>"},{"location":"dcim/#config-rendering","title":"Config Rendering","text":"<p>The <code>render_config</code> property renders device configuration based on config contexts and templates.</p> <p>Example: <pre><code>device = nb.dcim.devices.get(name='switch1')\nconfig = device.render_config.create()\nprint(config)\n</code></pre></p>"},{"location":"dcim/#pynetbox.models.dcim.Devices.render_config","title":"<code>pynetbox.models.dcim.Devices.render_config</code>  <code>property</code> <code>readonly</code>","text":"<p>Represents the <code>render-config</code> detail endpoint.</p> <p>Returns a DetailEndpoint object that is the interface for viewing response from the render-config endpoint.</p>"},{"location":"dcim/#pynetbox.models.dcim.Devices.render_config--returns","title":"Returns","text":"<p>DetailEndpoint object.</p>"},{"location":"dcim/#pynetbox.models.dcim.Devices.render_config--examples","title":"Examples","text":"<pre><code>device = nb.ipam.devices.get(123)\ndevice.render_config.create()\n</code></pre>"},{"location":"dcim/#racks","title":"Racks","text":""},{"location":"dcim/#rack-units","title":"Rack Units","text":"<p>The <code>units</code> property provides access to rack unit information.</p> <p>Example: <pre><code>rack = nb.dcim.racks.get(name='RACK-01')\nunits = rack.units.list()\n\nfor unit in units:\n    if unit.device:\n        print(f\"U{unit.name}: {unit.device.name}\")\n    else:\n        print(f\"U{unit.name}: Empty\")\n</code></pre></p>"},{"location":"dcim/#pynetbox.models.dcim.Racks.units","title":"<code>pynetbox.models.dcim.Racks.units</code>  <code>property</code> <code>readonly</code>","text":"<p>Represents the <code>units</code> detail endpoint.</p> <p>Returns a DetailEndpoint object that is the interface for viewing response from the units endpoint.</p>"},{"location":"dcim/#pynetbox.models.dcim.Racks.units--returns","title":"Returns","text":"<p>DetailEndpoint object.</p>"},{"location":"dcim/#pynetbox.models.dcim.Racks.units--examples","title":"Examples","text":"<pre><code>rack = nb.dcim.racks.get(123)\nrack.units.list()\n# {\"get_facts\": {\"interface_list\": [\"ge-0/0/0\"]}}\n</code></pre>"},{"location":"dcim/#rack-elevation","title":"Rack Elevation","text":"<p>The <code>elevation</code> property supports both JSON and SVG output for rack elevation diagrams.</p> <p>Examples: <pre><code>rack = nb.dcim.racks.get(name='RACK-01')\n\n# Get elevation as JSON (returns list of RU objects)\nelevation_data = rack.elevation.list()\n\n# Get elevation as SVG diagram\nsvg_diagram = rack.elevation.list(render='svg')\n\n# Save SVG to file\nwith open('rack-elevation.svg', 'w') as f:\n    f.write(svg_diagram)\n</code></pre></p>"},{"location":"dcim/#pynetbox.models.dcim.Racks.elevation","title":"<code>pynetbox.models.dcim.Racks.elevation</code>  <code>property</code> <code>readonly</code>","text":"<p>Represents the <code>elevation</code> detail endpoint.</p> <p>Returns a multi-format endpoint supporting both JSON and SVG responses. The elevation endpoint provides rack unit information and can render graphical elevation views.</p>"},{"location":"dcim/#pynetbox.models.dcim.Racks.elevation--returns","title":"Returns","text":"<p>ROMultiFormatDetailEndpoint object supporting JSON and SVG formats.</p>"},{"location":"dcim/#pynetbox.models.dcim.Racks.elevation--examples","title":"Examples","text":"<pre><code>rack = nb.dcim.racks.get(123)\n\n# Get rack units as JSON (list of RU objects)\nrack.elevation.list()\n\n# Get elevation as SVG diagram\nsvg = rack.elevation.list(render='svg')\n</code></pre>"},{"location":"dcim/#cable-tracing","title":"Cable Tracing","text":"<p>Several DCIM models support cable path tracing through the <code>trace()</code> method.</p> <p>Models with cable tracing: - Interfaces - ConsolePorts - ConsoleServerPorts - PowerPorts - PowerOutlets - PowerFeeds</p> <p>Example: <pre><code># Trace a network interface\ninterface = nb.dcim.interfaces.get(name='eth0', device='switch1')\ntrace_result = interface.trace()\n\n# The trace returns a list of [terminations, cable, terminations]\nfor item in trace_result:\n    if isinstance(item, list):\n        # Terminations\n        for term in item:\n            print(f\"  Termination: {term}\")\n    else:\n        # Cable or None\n        if item:\n            print(f\"  Cable: {item.id} - {item.label}\")\n        else:\n            print(\"  No cable\")\n\n# Trace console port\nconsole = nb.dcim.console_ports.get(name='Console', device='router1')\nconsole_trace = console.trace()\n\n# Trace power connections\npower_port = nb.dcim.power_ports.get(name='PSU1', device='server1')\npower_trace = power_port.trace()\n</code></pre></p>"},{"location":"dcim/#cable-path-tracing-pass-through-ports","title":"Cable Path Tracing (Pass-Through Ports)","text":"<p>Front ports and rear ports use the <code>paths()</code> method instead of <code>trace()</code>.</p> <p>Models with cable path tracing: - FrontPorts - RearPorts</p> <p>Example: <pre><code># Get paths through a front port\nfront_port = nb.dcim.front_ports.get(name='FrontPort1', device='patch-panel-1')\npaths = front_port.paths()\n\n# Each path contains origin, destination, and path segments\nfor path_info in paths:\n    print(f\"Origin: {path_info['origin']}\")\n    print(f\"Destination: {path_info['destination']}\")\n    print(\"Path segments:\")\n    for segment in path_info['path']:\n        for obj in segment:\n            print(f\"  - {obj}\")\n\n# Get paths through a rear port\nrear_port = nb.dcim.rear_ports.get(name='RearPort1', device='patch-panel-1')\nrear_paths = rear_port.paths()\n\n# Access the complete path from origin to destination\nif rear_paths:\n    first_path = rear_paths[0]\n    if first_path['origin']:\n        print(f\"Cable path starts at: {first_path['origin']}\")\n    if first_path['destination']:\n        print(f\"Cable path ends at: {first_path['destination']}\")\n</code></pre></p> <p>Path Structure:</p> <p>The <code>paths()</code> method returns a list of dictionaries, where each dictionary represents a complete cable path:</p> <ul> <li><code>origin</code>: The starting endpoint of the path (Record object or None if unconnected)</li> <li><code>destination</code>: The ending endpoint of the path (Record object or None if unconnected)</li> <li><code>path</code>: A list of path segments, where each segment is a list of Record objects representing the components in that segment (cables, terminations, etc.)</li> </ul>"},{"location":"endpoint/","title":"Endpoint","text":"<p><code>Endpoint</code> objects provide CRUD operations for NetBox API endpoints. They are automatically created when you access attributes on App objects.</p>"},{"location":"endpoint/#overview","title":"Overview","text":"<pre><code>import pynetbox\n\nnb = pynetbox.api('http://localhost:8000', token='your-token')\n\n# Accessing an attribute on an App returns an Endpoint\ndevices = nb.dcim.devices  # This is an Endpoint instance\n\n# Use Endpoint methods for CRUD operations\nall_devices = devices.all()\ndevice = devices.get(1)\nfiltered = devices.filter(site='headquarters')\nnew_device = devices.create(name='test', site=1, device_type=1, device_role=1)\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint","title":"<code> pynetbox.core.endpoint.Endpoint        </code>","text":"<p>Represent actions available on endpoints in the Netbox API.</p> <p>Takes <code>name</code> and <code>app</code> passed from App() and builds the correct url to make queries to and the proper Response object to return results in.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint--parameters","title":"Parameters","text":"<ul> <li>api (Api): Takes Api created at instantiation.</li> <li>app (App): Takes App.</li> <li>name (str): Name of endpoint passed to App().</li> <li>model (obj, optional): Custom model for given app.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint--note","title":"Note","text":"<p>In order to call NetBox endpoints with dashes in their names you should convert the dash to an underscore. (E.g. querying the ip-addresses endpoint is done with <code>nb.ipam.ip_addresses.all()</code>.)</p> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>class Endpoint:\n    \"\"\"Represent actions available on endpoints in the Netbox API.\n\n    Takes ``name`` and ``app`` passed from App() and builds the correct\n    url to make queries to and the proper Response object to return\n    results in.\n\n    ## Parameters\n\n    * **api** (Api): Takes Api created at instantiation.\n    * **app** (App): Takes App.\n    * **name** (str): Name of endpoint passed to App().\n    * **model** (obj, optional): Custom model for given app.\n\n    ## Note\n\n    In order to call NetBox endpoints with dashes in their\n    names you should convert the dash to an underscore.\n    (E.g. querying the ip-addresses endpoint is done with\n    ``nb.ipam.ip_addresses.all()``.)\n    \"\"\"\n\n    def __init__(self, api, app, name, model=None):\n        self.return_obj = self._lookup_ret_obj(name, model)\n        self.name = name.replace(\"_\", \"-\")\n        self.api = api\n        self.app = app\n        self.base_url = api.base_url\n        self.token = api.token\n        self.url = \"{base_url}/{app}/{endpoint}\".format(\n            base_url=self.base_url,\n            app=app.name,\n            endpoint=self.name,\n        )\n        self._choices = None\n\n    def _lookup_ret_obj(self, name, model):\n        \"\"\"Loads unique Response objects.\n\n        This method loads a unique response object for an endpoint if\n        it exists. Otherwise return a generic `Record` object.\n\n        ## Parameters\n\n        * **name** (str): Endpoint name.\n        * **model** (obj): The application model that contains unique Record objects.\n\n        ## Returns\n        Record (obj)\n        \"\"\"\n        if model:\n            name = name.title().replace(\"_\", \"\")\n            ret = getattr(model, name, Record)\n        else:\n            ret = Record\n        return ret\n\n    def _validate_openapi_parameters(self, method: str, parameters: dict) -&gt; None:\n        \"\"\"Validate GET request parameters against OpenAPI specification\n\n        This method raises a **ParameterValidationError** if parameters passed to NetBox API\n        do not match the OpenAPI specification or validation fails.\n\n        ## Parameters\n\n        * **method** : Only \"get\" is supported as for other methods NetBox already does proper validation\n        * **parameters** : kwargs passed to filter() method\n\n        ## Returns\n        None\n        \"\"\"\n        if method.lower() != \"get\":\n            raise RuntimeError(f\"Unsupported method '{method}'.\")\n\n        openapi_definition_path = \"/api/{app}/{endpoint}/\".format(\n            app=self.app.name,\n            endpoint=self.name,\n        )\n\n        # Parse NetBox OpenAPI definition\n        try:\n            openapi_definition = self.api.openapi()[\"paths\"].get(\n                openapi_definition_path\n            )\n\n            if not openapi_definition:\n                raise ParameterValidationError(\n                    f\"Path '{openapi_definition_path}' does not exist in NetBox OpenAPI specification.\"\n                )\n\n            openapi_parameters = openapi_definition[method][\"parameters\"]\n            allowed_parameters = [p[\"name\"] for p in openapi_parameters]\n\n        except KeyError as exc:\n            raise ParameterValidationError(\n                f\"Error while parsing Netbox OpenAPI specification: {exc}\"\n            )\n\n        # Validate all parameters\n        validation_errors = []\n        for p in parameters:\n            if p not in allowed_parameters:\n                validation_errors.append(\n                    f\"'{p}' is not allowed as parameter on path '{openapi_definition_path}'.\"\n                )\n\n        if len(validation_errors) &gt; 0:\n            raise ParameterValidationError(validation_errors)\n\n    def all(self, limit=0, offset=None):\n        \"\"\"Queries the 'ListView' of a given endpoint.\n\n        Returns all objects from an endpoint.\n\n        ## Parameters\n\n        * **limit** (int, optional): Overrides the max page size on\n            paginated returns. This defines the number of records that will\n            be returned with each query to the Netbox server. The queries\n            will be made as you iterate through the result set.\n        * **offset** (int, optional): Overrides the offset on paginated returns.\n\n        ## Returns\n        A RecordSet object.\n\n        ## Examples\n\n        ```python\n        devices = list(nb.dcim.devices.all())\n        for device in devices:\n            print(device.name)\n\n        # test1-leaf1\n        # test1-leaf2\n        # test1-leaf3\n        ```\n\n        If you want to iterate over the results multiple times then\n        encapsulate them in a list like this:\n        ```python\n        devices = list(nb.dcim.devices.all())\n        ```\n\n        This will cause the entire result set\n        to be fetched from the server.\n        \"\"\"\n        if limit == 0 and offset is not None:\n            raise ValueError(\"offset requires a positive limit value\")\n        req = Request(\n            base=\"{}/\".format(self.url),\n            token=self.token,\n            http_session=self.api.http_session,\n            threading=self.api.threading,\n            limit=limit,\n            offset=offset,\n        )\n\n        return RecordSet(self, req)\n\n    def get(self, *args, **kwargs):\n        \"\"\"Queries the DetailsView of a given endpoint.\n\n        ## Parameters\n\n        * **key** (int, optional): id for the item to be retrieved.\n        * **kwargs**: Accepts the same keyword args as filter(). Any search argument the endpoint accepts can\n            be added as a keyword arg.\n        * **strict_filters** (bool, optional): Overrides the global filter\n            validation per-request basis. Handled by the filter() method.\n\n        ## Returns\n        A single Record object or None\n\n        ## Raises\n        ValueError: if kwarg search return more than one value.\n\n        ## Examples\n\n        Referencing with a kwarg that only returns one value:\n\n        ```python\n        nb.dcim.devices.get(name='test1-a3-tor1b')\n        # test1-a3-tor1b\n        ```\n\n        Referencing with an id:\n\n        ```python\n        nb.dcim.devices.get(1)\n        # test1-edge1\n        ```\n\n        Using multiple named arguments. For example, retrieving the location when the location name is not unique and used in multiple sites:\n\n        ```python\n        nb.locations.get(site='site-1', name='Row 1')\n        # Row 1\n        ```\n        \"\"\"\n        try:\n            key = args[0]\n        except IndexError:\n            key = None\n\n        if not key:\n            resp = self.filter(**kwargs)\n            ret = next(resp, None)\n            if not ret:\n                return ret\n            try:\n                next(resp)\n                raise ValueError(\n                    \"get() returned more than one result. \"\n                    \"Check that the kwarg(s) passed are valid for this \"\n                    \"endpoint or use filter() or all() instead.\"\n                )\n            except StopIteration:\n                return ret\n\n        req = Request(\n            key=key,\n            base=self.url,\n            token=self.token,\n            http_session=self.api.http_session,\n        )\n        try:\n            return next(RecordSet(self, req), None)\n        except RequestError as e:\n            if e.req.status_code == 404:\n                return None\n            else:\n                raise e\n\n    def filter(self, *args, **kwargs):\n        \"\"\"Queries the 'ListView' of a given endpoint.\n\n        Takes named arguments that match the usable filters on a\n        given endpoint. If an argument is passed then it's used as a\n        freeform search argument if the endpoint supports it.\n\n        ## Parameters\n\n        * **args** (str, optional): Freeform search string that's\n            accepted on given endpoint.\n        * **kwargs** (str, optional): Any search argument the\n            endpoint accepts can be added as a keyword arg.\n        * **limit** (int, optional): Overrides the max page size on\n            paginated returns. This defines the number of records that will\n            be returned with each query to the Netbox server. The queries\n            will be made as you iterate through the result set.\n        * **offset** (int, optional): Overrides the offset on paginated returns.\n        * **strict_filters** (bool, optional): Overrides the global filter\n            validation per-request basis.\n\n        ## Returns\n        A RecordSet object.\n\n        ## Examples\n\n        To return a list of objects matching a named argument filter:\n\n        ```python\n        devices = nb.dcim.devices.filter(role='leaf-switch')\n        for device in devices:\n            print(device.name)\n\n        # test1-leaf1\n        # test1-leaf2\n        # test1-leaf3\n        ```\n\n        ```python\n        devices = nb.dcim.devices.filter(site='site-1')\n        for device in devices:\n            print(device.name)\n\n        # test1-a2-leaf1\n        # test2-a2-leaf2\n        ```\n\n        ## Note\n\n        If a keyword argument is incorrect a `TypeError` will not be returned by pynetbox.\n        Instead, pynetbox will return all records filtered up to the last correct keyword argument. For example, if we used `site=\"Site 1\"` instead of `site=site-1` when using filter on\n        the devices endpoint, then pynetbox will return **all** devices across all sites instead of devices at Site 1.\n\n        Using a freeform query along with a named argument:\n\n        ```python\n        devices = nb.dcim.devices.filter('a3', role='leaf-switch')\n        for device in devices:\n            print(device.name)\n\n        # test1-a3-leaf1\n        # test1-a3-leaf2\n        ```\n        \"\"\"\n\n        if args:\n            kwargs.update({\"q\": args[0]})\n\n        if any(i in RESERVED_KWARGS for i in kwargs):\n            raise ValueError(\n                \"A reserved kwarg was passed ({}). Please remove it \"\n                \"and try again.\".format(RESERVED_KWARGS)\n            )\n        limit = kwargs.pop(\"limit\") if \"limit\" in kwargs else 0\n        offset = kwargs.pop(\"offset\") if \"offset\" in kwargs else None\n        strict_filters = (\n            # kwargs value takes precedence on globally set value\n            kwargs.pop(\"strict_filters\")\n            if \"strict_filters\" in kwargs\n            else self.api.strict_filters\n        )\n\n        if limit == 0 and offset is not None:\n            raise ValueError(\"offset requires a positive limit value\")\n        filters = {x: y if y is not None else \"null\" for x, y in kwargs.items()}\n\n        if strict_filters:\n            self._validate_openapi_parameters(\"get\", filters)\n\n        req = Request(\n            filters=filters,\n            base=self.url,\n            token=self.token,\n            http_session=self.api.http_session,\n            threading=self.api.threading,\n            limit=limit,\n            offset=offset,\n        )\n\n        return RecordSet(self, req)\n\n    def create(self, *args, **kwargs):\n        \"\"\"Creates an object on an endpoint.\n\n        Takes named arguments that match the given endpoint's\n        available fields. Returns a new object.\n\n        ## Parameters\n\n        * **args**: Not used.\n        * **kwargs**: Fields and values to create the object with.\n\n        ## Returns\n        A Record object.\n\n        ## Examples\n\n        Creating a new device:\n\n        ```python\n        new_device = nb.dcim.devices.create(\n            name='test-device',\n            device_type=1,\n            device_role=1,\n            site=1\n        )\n        ```\n\n        Creating a new device with a nested object:\n\n        ```python\n        new_device = nb.dcim.devices.create(\n            name='test-device',\n            device_type={'id': 1},\n            device_role={'id': 1},\n            site={'id': 1}\n        )\n        ```\n        \"\"\"\n\n        req = Request(\n            base=self.url,\n            token=self.token,\n            http_session=self.api.http_session,\n        ).post(args[0] if args else kwargs)\n\n        if isinstance(req, list):\n            return [self.return_obj(i, self.api, self) for i in req]\n        return self.return_obj(req, self.api, self)\n\n    def update(self, objects):\n        \"\"\"Updates objects in NetBox.\n\n        Takes a list of objects and updates them in NetBox.\n\n        ## Parameters\n\n        * **objects** (list): A list of Record objects to update.\n\n        ## Returns\n        A list of Record objects.\n\n        ## Examples\n\n        ```python\n        devices = nb.dcim.devices.filter(site='test1')\n        for device in devices:\n            device.status = 'active'\n        nb.dcim.devices.update(devices)\n        ```\n        \"\"\"\n        series = []\n        if not isinstance(objects, list):\n            raise ValueError(\n                \"Objects passed must be list[dict|Record] - was {}\".format(\n                    type(objects)\n                )\n            )\n        for o in objects:\n            if isinstance(o, Record):\n                data = o.updates()\n                if data:\n                    data[\"id\"] = o.id\n                    series.append(data)\n            elif isinstance(o, dict):\n                if \"id\" not in o:\n                    raise ValueError(\"id is missing from object: \" + str(o))\n                series.append(o)\n            else:\n                raise ValueError(\n                    \"Object passed must be dict|Record - was {}\".format(type(objects))\n                )\n        req = Request(\n            base=self.url,\n            token=self.token,\n            http_session=self.api.http_session,\n        ).patch(series)\n\n        if isinstance(req, list):\n            return [self.return_obj(i, self.api, self) for i in req]\n        return self.return_obj(req, self.api, self)\n\n    def delete(self, objects):\n        \"\"\"Deletes objects from NetBox.\n\n        Takes a list of objects and deletes them from NetBox.\n\n        ## Parameters\n\n        * **objects** (list): A list of Record objects to delete.\n\n        ## Returns\n        True if the delete operation was successful.\n\n        ## Examples\n\n        ```python\n        devices = nb.dcim.devices.filter(site='test1')\n        nb.dcim.devices.delete(devices)\n        ```\n        \"\"\"\n        cleaned_ids = []\n        if not isinstance(objects, list) and not isinstance(objects, RecordSet):\n            raise ValueError(\n                \"objects must be list[str|int|Record]\"\n                \"|RecordSet - was \" + str(type(objects))\n            )\n        for o in objects:\n            if isinstance(o, int):\n                cleaned_ids.append(o)\n            elif isinstance(o, str) and o.isnumeric():\n                cleaned_ids.append(int(o))\n            elif isinstance(o, Record):\n                if not hasattr(o, \"id\"):\n                    raise ValueError(\n                        \"Record from '\"\n                        + o.url\n                        + \"' does not have an id and cannot be bulk deleted\"\n                    )\n                cleaned_ids.append(o.id)\n            else:\n                raise ValueError(\n                    \"Invalid object in list of objects to delete: \" + str(type(o))\n                )\n\n        req = Request(\n            base=self.url,\n            token=self.token,\n            http_session=self.api.http_session,\n        )\n        return True if req.delete(data=[{\"id\": i} for i in cleaned_ids]) else False\n\n    def choices(self):\n        \"\"\"Returns all choices from the endpoint if it has them.\n\n        ## Returns\n        Dictionary of available choices.\n\n        ## Examples\n\n        ```python\n        choices = nb.dcim.devices.choices()\n        print(choices['status'])\n        {\n            'label': 'Active',\n            'value': 'active'\n        }\n        ```\n        \"\"\"\n        if self._choices:\n            return self._choices\n\n        req = Request(\n            base=self.url,\n            token=self.api.token,\n            http_session=self.api.http_session,\n        ).options()\n\n        actions = req.get(\"actions\", {})\n        post_data = actions.get(\"POST\") or actions.get(\"PUT\")\n        if post_data is None:\n            raise ValueError(\n                \"Unexpected format in the OPTIONS response at {}\".format(self.url)\n            )\n        self._choices = {}\n        for prop in post_data:\n            if \"choices\" in post_data[prop]:\n                self._choices[prop] = post_data[prop][\"choices\"]\n\n        return self._choices\n\n    def count(self, *args, **kwargs):\n        \"\"\"Returns the count of objects in a query.\n\n        Takes named arguments that match the usable filters on a\n        given endpoint. If an argument is passed then it's used as a\n        freeform search argument if the endpoint supports it.\n\n        ## Parameters\n\n        * **args** (str, optional): Freeform search string that's\n            accepted on given endpoint.\n        * **kwargs** (str, optional): Any search argument the\n            endpoint accepts can be added as a keyword arg.\n\n        ## Returns\n        Integer of count of objects.\n\n        ## Examples\n\n        ```python\n        nb.dcim.devices.count(site='test1')\n        # 27\n        ```\n        \"\"\"\n\n        if args:\n            kwargs.update({\"q\": args[0]})\n\n        if any(i in RESERVED_KWARGS for i in kwargs):\n            raise ValueError(\n                \"A reserved {} kwarg was passed. Please remove it \"\n                \"try again.\".format(RESERVED_KWARGS)\n            )\n\n        ret = Request(\n            filters=kwargs,\n            base=self.url,\n            token=self.token,\n            http_session=self.api.http_session,\n        )\n\n        return ret.get_count()\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.all","title":"<code>all(self, limit=0, offset=None)</code>","text":"<p>Queries the 'ListView' of a given endpoint.</p> <p>Returns all objects from an endpoint.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.all--parameters","title":"Parameters","text":"<ul> <li>limit (int, optional): Overrides the max page size on     paginated returns. This defines the number of records that will     be returned with each query to the Netbox server. The queries     will be made as you iterate through the result set.</li> <li>offset (int, optional): Overrides the offset on paginated returns.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.all--returns","title":"Returns","text":"<p>A RecordSet object.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.all--examples","title":"Examples","text":"<pre><code>devices = list(nb.dcim.devices.all())\nfor device in devices:\n    print(device.name)\n\n# test1-leaf1\n# test1-leaf2\n# test1-leaf3\n</code></pre> <p>If you want to iterate over the results multiple times then encapsulate them in a list like this: <pre><code>devices = list(nb.dcim.devices.all())\n</code></pre></p> <p>This will cause the entire result set to be fetched from the server.</p> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def all(self, limit=0, offset=None):\n    \"\"\"Queries the 'ListView' of a given endpoint.\n\n    Returns all objects from an endpoint.\n\n    ## Parameters\n\n    * **limit** (int, optional): Overrides the max page size on\n        paginated returns. This defines the number of records that will\n        be returned with each query to the Netbox server. The queries\n        will be made as you iterate through the result set.\n    * **offset** (int, optional): Overrides the offset on paginated returns.\n\n    ## Returns\n    A RecordSet object.\n\n    ## Examples\n\n    ```python\n    devices = list(nb.dcim.devices.all())\n    for device in devices:\n        print(device.name)\n\n    # test1-leaf1\n    # test1-leaf2\n    # test1-leaf3\n    ```\n\n    If you want to iterate over the results multiple times then\n    encapsulate them in a list like this:\n    ```python\n    devices = list(nb.dcim.devices.all())\n    ```\n\n    This will cause the entire result set\n    to be fetched from the server.\n    \"\"\"\n    if limit == 0 and offset is not None:\n        raise ValueError(\"offset requires a positive limit value\")\n    req = Request(\n        base=\"{}/\".format(self.url),\n        token=self.token,\n        http_session=self.api.http_session,\n        threading=self.api.threading,\n        limit=limit,\n        offset=offset,\n    )\n\n    return RecordSet(self, req)\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.choices","title":"<code>choices(self)</code>","text":"<p>Returns all choices from the endpoint if it has them.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.choices--returns","title":"Returns","text":"<p>Dictionary of available choices.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.choices--examples","title":"Examples","text":"<pre><code>choices = nb.dcim.devices.choices()\nprint(choices['status'])\n{\n    'label': 'Active',\n    'value': 'active'\n}\n</code></pre> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def choices(self):\n    \"\"\"Returns all choices from the endpoint if it has them.\n\n    ## Returns\n    Dictionary of available choices.\n\n    ## Examples\n\n    ```python\n    choices = nb.dcim.devices.choices()\n    print(choices['status'])\n    {\n        'label': 'Active',\n        'value': 'active'\n    }\n    ```\n    \"\"\"\n    if self._choices:\n        return self._choices\n\n    req = Request(\n        base=self.url,\n        token=self.api.token,\n        http_session=self.api.http_session,\n    ).options()\n\n    actions = req.get(\"actions\", {})\n    post_data = actions.get(\"POST\") or actions.get(\"PUT\")\n    if post_data is None:\n        raise ValueError(\n            \"Unexpected format in the OPTIONS response at {}\".format(self.url)\n        )\n    self._choices = {}\n    for prop in post_data:\n        if \"choices\" in post_data[prop]:\n            self._choices[prop] = post_data[prop][\"choices\"]\n\n    return self._choices\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.count","title":"<code>count(self, *args, **kwargs)</code>","text":"<p>Returns the count of objects in a query.</p> <p>Takes named arguments that match the usable filters on a given endpoint. If an argument is passed then it's used as a freeform search argument if the endpoint supports it.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.count--parameters","title":"Parameters","text":"<ul> <li>args (str, optional): Freeform search string that's     accepted on given endpoint.</li> <li>kwargs (str, optional): Any search argument the     endpoint accepts can be added as a keyword arg.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.count--returns","title":"Returns","text":"<p>Integer of count of objects.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.count--examples","title":"Examples","text":"<pre><code>nb.dcim.devices.count(site='test1')\n# 27\n</code></pre> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def count(self, *args, **kwargs):\n    \"\"\"Returns the count of objects in a query.\n\n    Takes named arguments that match the usable filters on a\n    given endpoint. If an argument is passed then it's used as a\n    freeform search argument if the endpoint supports it.\n\n    ## Parameters\n\n    * **args** (str, optional): Freeform search string that's\n        accepted on given endpoint.\n    * **kwargs** (str, optional): Any search argument the\n        endpoint accepts can be added as a keyword arg.\n\n    ## Returns\n    Integer of count of objects.\n\n    ## Examples\n\n    ```python\n    nb.dcim.devices.count(site='test1')\n    # 27\n    ```\n    \"\"\"\n\n    if args:\n        kwargs.update({\"q\": args[0]})\n\n    if any(i in RESERVED_KWARGS for i in kwargs):\n        raise ValueError(\n            \"A reserved {} kwarg was passed. Please remove it \"\n            \"try again.\".format(RESERVED_KWARGS)\n        )\n\n    ret = Request(\n        filters=kwargs,\n        base=self.url,\n        token=self.token,\n        http_session=self.api.http_session,\n    )\n\n    return ret.get_count()\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.create","title":"<code>create(self, *args, **kwargs)</code>","text":"<p>Creates an object on an endpoint.</p> <p>Takes named arguments that match the given endpoint's available fields. Returns a new object.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.create--parameters","title":"Parameters","text":"<ul> <li>args: Not used.</li> <li>kwargs: Fields and values to create the object with.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.create--returns","title":"Returns","text":"<p>A Record object.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.create--examples","title":"Examples","text":"<p>Creating a new device:</p> <pre><code>new_device = nb.dcim.devices.create(\n    name='test-device',\n    device_type=1,\n    device_role=1,\n    site=1\n)\n</code></pre> <p>Creating a new device with a nested object:</p> <pre><code>new_device = nb.dcim.devices.create(\n    name='test-device',\n    device_type={'id': 1},\n    device_role={'id': 1},\n    site={'id': 1}\n)\n</code></pre> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def create(self, *args, **kwargs):\n    \"\"\"Creates an object on an endpoint.\n\n    Takes named arguments that match the given endpoint's\n    available fields. Returns a new object.\n\n    ## Parameters\n\n    * **args**: Not used.\n    * **kwargs**: Fields and values to create the object with.\n\n    ## Returns\n    A Record object.\n\n    ## Examples\n\n    Creating a new device:\n\n    ```python\n    new_device = nb.dcim.devices.create(\n        name='test-device',\n        device_type=1,\n        device_role=1,\n        site=1\n    )\n    ```\n\n    Creating a new device with a nested object:\n\n    ```python\n    new_device = nb.dcim.devices.create(\n        name='test-device',\n        device_type={'id': 1},\n        device_role={'id': 1},\n        site={'id': 1}\n    )\n    ```\n    \"\"\"\n\n    req = Request(\n        base=self.url,\n        token=self.token,\n        http_session=self.api.http_session,\n    ).post(args[0] if args else kwargs)\n\n    if isinstance(req, list):\n        return [self.return_obj(i, self.api, self) for i in req]\n    return self.return_obj(req, self.api, self)\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.delete","title":"<code>delete(self, objects)</code>","text":"<p>Deletes objects from NetBox.</p> <p>Takes a list of objects and deletes them from NetBox.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.delete--parameters","title":"Parameters","text":"<ul> <li>objects (list): A list of Record objects to delete.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.delete--returns","title":"Returns","text":"<p>True if the delete operation was successful.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.delete--examples","title":"Examples","text":"<pre><code>devices = nb.dcim.devices.filter(site='test1')\nnb.dcim.devices.delete(devices)\n</code></pre> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def delete(self, objects):\n    \"\"\"Deletes objects from NetBox.\n\n    Takes a list of objects and deletes them from NetBox.\n\n    ## Parameters\n\n    * **objects** (list): A list of Record objects to delete.\n\n    ## Returns\n    True if the delete operation was successful.\n\n    ## Examples\n\n    ```python\n    devices = nb.dcim.devices.filter(site='test1')\n    nb.dcim.devices.delete(devices)\n    ```\n    \"\"\"\n    cleaned_ids = []\n    if not isinstance(objects, list) and not isinstance(objects, RecordSet):\n        raise ValueError(\n            \"objects must be list[str|int|Record]\"\n            \"|RecordSet - was \" + str(type(objects))\n        )\n    for o in objects:\n        if isinstance(o, int):\n            cleaned_ids.append(o)\n        elif isinstance(o, str) and o.isnumeric():\n            cleaned_ids.append(int(o))\n        elif isinstance(o, Record):\n            if not hasattr(o, \"id\"):\n                raise ValueError(\n                    \"Record from '\"\n                    + o.url\n                    + \"' does not have an id and cannot be bulk deleted\"\n                )\n            cleaned_ids.append(o.id)\n        else:\n            raise ValueError(\n                \"Invalid object in list of objects to delete: \" + str(type(o))\n            )\n\n    req = Request(\n        base=self.url,\n        token=self.token,\n        http_session=self.api.http_session,\n    )\n    return True if req.delete(data=[{\"id\": i} for i in cleaned_ids]) else False\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.filter","title":"<code>filter(self, *args, **kwargs)</code>","text":"<p>Queries the 'ListView' of a given endpoint.</p> <p>Takes named arguments that match the usable filters on a given endpoint. If an argument is passed then it's used as a freeform search argument if the endpoint supports it.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.filter--parameters","title":"Parameters","text":"<ul> <li>args (str, optional): Freeform search string that's     accepted on given endpoint.</li> <li>kwargs (str, optional): Any search argument the     endpoint accepts can be added as a keyword arg.</li> <li>limit (int, optional): Overrides the max page size on     paginated returns. This defines the number of records that will     be returned with each query to the Netbox server. The queries     will be made as you iterate through the result set.</li> <li>offset (int, optional): Overrides the offset on paginated returns.</li> <li>strict_filters (bool, optional): Overrides the global filter     validation per-request basis.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.filter--returns","title":"Returns","text":"<p>A RecordSet object.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.filter--examples","title":"Examples","text":"<p>To return a list of objects matching a named argument filter:</p> <pre><code>devices = nb.dcim.devices.filter(role='leaf-switch')\nfor device in devices:\n    print(device.name)\n\n# test1-leaf1\n# test1-leaf2\n# test1-leaf3\n</code></pre> <pre><code>devices = nb.dcim.devices.filter(site='site-1')\nfor device in devices:\n    print(device.name)\n\n# test1-a2-leaf1\n# test2-a2-leaf2\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.filter--note","title":"Note","text":"<p>If a keyword argument is incorrect a <code>TypeError</code> will not be returned by pynetbox. Instead, pynetbox will return all records filtered up to the last correct keyword argument. For example, if we used <code>site=\"Site 1\"</code> instead of <code>site=site-1</code> when using filter on the devices endpoint, then pynetbox will return all devices across all sites instead of devices at Site 1.</p> <p>Using a freeform query along with a named argument:</p> <pre><code>devices = nb.dcim.devices.filter('a3', role='leaf-switch')\nfor device in devices:\n    print(device.name)\n\n# test1-a3-leaf1\n# test1-a3-leaf2\n</code></pre> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def filter(self, *args, **kwargs):\n    \"\"\"Queries the 'ListView' of a given endpoint.\n\n    Takes named arguments that match the usable filters on a\n    given endpoint. If an argument is passed then it's used as a\n    freeform search argument if the endpoint supports it.\n\n    ## Parameters\n\n    * **args** (str, optional): Freeform search string that's\n        accepted on given endpoint.\n    * **kwargs** (str, optional): Any search argument the\n        endpoint accepts can be added as a keyword arg.\n    * **limit** (int, optional): Overrides the max page size on\n        paginated returns. This defines the number of records that will\n        be returned with each query to the Netbox server. The queries\n        will be made as you iterate through the result set.\n    * **offset** (int, optional): Overrides the offset on paginated returns.\n    * **strict_filters** (bool, optional): Overrides the global filter\n        validation per-request basis.\n\n    ## Returns\n    A RecordSet object.\n\n    ## Examples\n\n    To return a list of objects matching a named argument filter:\n\n    ```python\n    devices = nb.dcim.devices.filter(role='leaf-switch')\n    for device in devices:\n        print(device.name)\n\n    # test1-leaf1\n    # test1-leaf2\n    # test1-leaf3\n    ```\n\n    ```python\n    devices = nb.dcim.devices.filter(site='site-1')\n    for device in devices:\n        print(device.name)\n\n    # test1-a2-leaf1\n    # test2-a2-leaf2\n    ```\n\n    ## Note\n\n    If a keyword argument is incorrect a `TypeError` will not be returned by pynetbox.\n    Instead, pynetbox will return all records filtered up to the last correct keyword argument. For example, if we used `site=\"Site 1\"` instead of `site=site-1` when using filter on\n    the devices endpoint, then pynetbox will return **all** devices across all sites instead of devices at Site 1.\n\n    Using a freeform query along with a named argument:\n\n    ```python\n    devices = nb.dcim.devices.filter('a3', role='leaf-switch')\n    for device in devices:\n        print(device.name)\n\n    # test1-a3-leaf1\n    # test1-a3-leaf2\n    ```\n    \"\"\"\n\n    if args:\n        kwargs.update({\"q\": args[0]})\n\n    if any(i in RESERVED_KWARGS for i in kwargs):\n        raise ValueError(\n            \"A reserved kwarg was passed ({}). Please remove it \"\n            \"and try again.\".format(RESERVED_KWARGS)\n        )\n    limit = kwargs.pop(\"limit\") if \"limit\" in kwargs else 0\n    offset = kwargs.pop(\"offset\") if \"offset\" in kwargs else None\n    strict_filters = (\n        # kwargs value takes precedence on globally set value\n        kwargs.pop(\"strict_filters\")\n        if \"strict_filters\" in kwargs\n        else self.api.strict_filters\n    )\n\n    if limit == 0 and offset is not None:\n        raise ValueError(\"offset requires a positive limit value\")\n    filters = {x: y if y is not None else \"null\" for x, y in kwargs.items()}\n\n    if strict_filters:\n        self._validate_openapi_parameters(\"get\", filters)\n\n    req = Request(\n        filters=filters,\n        base=self.url,\n        token=self.token,\n        http_session=self.api.http_session,\n        threading=self.api.threading,\n        limit=limit,\n        offset=offset,\n    )\n\n    return RecordSet(self, req)\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.get","title":"<code>get(self, *args, **kwargs)</code>","text":"<p>Queries the DetailsView of a given endpoint.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.get--parameters","title":"Parameters","text":"<ul> <li>key (int, optional): id for the item to be retrieved.</li> <li>kwargs: Accepts the same keyword args as filter(). Any search argument the endpoint accepts can     be added as a keyword arg.</li> <li>strict_filters (bool, optional): Overrides the global filter     validation per-request basis. Handled by the filter() method.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.get--returns","title":"Returns","text":"<p>A single Record object or None</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.get--raises","title":"Raises","text":"<p>ValueError: if kwarg search return more than one value.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.get--examples","title":"Examples","text":"<p>Referencing with a kwarg that only returns one value:</p> <pre><code>nb.dcim.devices.get(name='test1-a3-tor1b')\n# test1-a3-tor1b\n</code></pre> <p>Referencing with an id:</p> <pre><code>nb.dcim.devices.get(1)\n# test1-edge1\n</code></pre> <p>Using multiple named arguments. For example, retrieving the location when the location name is not unique and used in multiple sites:</p> <pre><code>nb.locations.get(site='site-1', name='Row 1')\n# Row 1\n</code></pre> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def get(self, *args, **kwargs):\n    \"\"\"Queries the DetailsView of a given endpoint.\n\n    ## Parameters\n\n    * **key** (int, optional): id for the item to be retrieved.\n    * **kwargs**: Accepts the same keyword args as filter(). Any search argument the endpoint accepts can\n        be added as a keyword arg.\n    * **strict_filters** (bool, optional): Overrides the global filter\n        validation per-request basis. Handled by the filter() method.\n\n    ## Returns\n    A single Record object or None\n\n    ## Raises\n    ValueError: if kwarg search return more than one value.\n\n    ## Examples\n\n    Referencing with a kwarg that only returns one value:\n\n    ```python\n    nb.dcim.devices.get(name='test1-a3-tor1b')\n    # test1-a3-tor1b\n    ```\n\n    Referencing with an id:\n\n    ```python\n    nb.dcim.devices.get(1)\n    # test1-edge1\n    ```\n\n    Using multiple named arguments. For example, retrieving the location when the location name is not unique and used in multiple sites:\n\n    ```python\n    nb.locations.get(site='site-1', name='Row 1')\n    # Row 1\n    ```\n    \"\"\"\n    try:\n        key = args[0]\n    except IndexError:\n        key = None\n\n    if not key:\n        resp = self.filter(**kwargs)\n        ret = next(resp, None)\n        if not ret:\n            return ret\n        try:\n            next(resp)\n            raise ValueError(\n                \"get() returned more than one result. \"\n                \"Check that the kwarg(s) passed are valid for this \"\n                \"endpoint or use filter() or all() instead.\"\n            )\n        except StopIteration:\n            return ret\n\n    req = Request(\n        key=key,\n        base=self.url,\n        token=self.token,\n        http_session=self.api.http_session,\n    )\n    try:\n        return next(RecordSet(self, req), None)\n    except RequestError as e:\n        if e.req.status_code == 404:\n            return None\n        else:\n            raise e\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.update","title":"<code>update(self, objects)</code>","text":"<p>Updates objects in NetBox.</p> <p>Takes a list of objects and updates them in NetBox.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.update--parameters","title":"Parameters","text":"<ul> <li>objects (list): A list of Record objects to update.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.update--returns","title":"Returns","text":"<p>A list of Record objects.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.update--examples","title":"Examples","text":"<pre><code>devices = nb.dcim.devices.filter(site='test1')\nfor device in devices:\n    device.status = 'active'\nnb.dcim.devices.update(devices)\n</code></pre> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def update(self, objects):\n    \"\"\"Updates objects in NetBox.\n\n    Takes a list of objects and updates them in NetBox.\n\n    ## Parameters\n\n    * **objects** (list): A list of Record objects to update.\n\n    ## Returns\n    A list of Record objects.\n\n    ## Examples\n\n    ```python\n    devices = nb.dcim.devices.filter(site='test1')\n    for device in devices:\n        device.status = 'active'\n    nb.dcim.devices.update(devices)\n    ```\n    \"\"\"\n    series = []\n    if not isinstance(objects, list):\n        raise ValueError(\n            \"Objects passed must be list[dict|Record] - was {}\".format(\n                type(objects)\n            )\n        )\n    for o in objects:\n        if isinstance(o, Record):\n            data = o.updates()\n            if data:\n                data[\"id\"] = o.id\n                series.append(data)\n        elif isinstance(o, dict):\n            if \"id\" not in o:\n                raise ValueError(\"id is missing from object: \" + str(o))\n            series.append(o)\n        else:\n            raise ValueError(\n                \"Object passed must be dict|Record - was {}\".format(type(objects))\n            )\n    req = Request(\n        base=self.url,\n        token=self.token,\n        http_session=self.api.http_session,\n    ).patch(series)\n\n    if isinstance(req, list):\n        return [self.return_obj(i, self.api, self) for i in req]\n    return self.return_obj(req, self.api, self)\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.DetailEndpoint","title":"<code> pynetbox.core.endpoint.DetailEndpoint        </code>","text":"<p>Enables read/write operations on detail endpoints.</p> <p>Endpoints like <code>available-ips</code> that are detail routes off traditional endpoints are handled with this class.</p> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>class DetailEndpoint:\n    \"\"\"Enables read/write operations on detail endpoints.\n\n    Endpoints like `available-ips` that are detail routes off\n    traditional endpoints are handled with this class.\n    \"\"\"\n\n    def __init__(self, parent_obj, name, custom_return=None):\n        self.parent_obj = parent_obj\n        self.custom_return = custom_return\n        self.url = \"{}/{}/{}/\".format(parent_obj.endpoint.url, parent_obj.id, name)\n        self.request_kwargs = dict(\n            base=self.url,\n            token=parent_obj.api.token,\n            http_session=parent_obj.api.http_session,\n        )\n\n    def list(self, **kwargs):\n        \"\"\"The view operation for a detail endpoint.\n\n        Returns the response from NetBox for a detail endpoint.\n\n        ## Parameters\n\n        * **kwargs**: Key/value pairs that get converted into URL\n            parameters when passed to the endpoint.\n            E.g. `.list(method='get_facts')` would be converted to\n            `.../?method=get_facts`.\n\n        ## Returns\n        A Record object or list of Record objects created\n        from data retrieved from NetBox.\n        \"\"\"\n        req = Request(**self.request_kwargs).get(add_params=kwargs)\n\n        if self.custom_return:\n            return [\n                self.custom_return(\n                    i, self.parent_obj.endpoint.api, self.parent_obj.endpoint\n                )\n                for i in req\n            ]\n        return req\n\n    def create(self, data=None):\n        \"\"\"The write operation for a detail endpoint.\n\n        Creates objects on a detail endpoint in NetBox.\n\n        ## Parameters\n\n        * **data** (dict/list, optional): A dictionary containing the\n            key/value pair of the items you're creating on the parent\n            object. Defaults to empty dict which will create a single\n            item with default values.\n\n        ## Returns\n        A Record object or list of Record objects created\n        from data created in NetBox.\n        \"\"\"\n        data = data or {}\n        req = Request(**self.request_kwargs).post(data)\n        if self.custom_return:\n            if isinstance(req, list):\n                return [\n                    self.custom_return(\n                        req_item, self.parent_obj.endpoint.api, self.parent_obj.endpoint\n                    )\n                    for req_item in req\n                ]\n            else:\n                return self.custom_return(\n                    req, self.parent_obj.endpoint.api, self.parent_obj.endpoint\n                )\n        return req\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.DetailEndpoint.create","title":"<code>create(self, data=None)</code>","text":"<p>The write operation for a detail endpoint.</p> <p>Creates objects on a detail endpoint in NetBox.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.DetailEndpoint.create--parameters","title":"Parameters","text":"<ul> <li>data (dict/list, optional): A dictionary containing the     key/value pair of the items you're creating on the parent     object. Defaults to empty dict which will create a single     item with default values.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.DetailEndpoint.create--returns","title":"Returns","text":"<p>A Record object or list of Record objects created from data created in NetBox.</p> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def create(self, data=None):\n    \"\"\"The write operation for a detail endpoint.\n\n    Creates objects on a detail endpoint in NetBox.\n\n    ## Parameters\n\n    * **data** (dict/list, optional): A dictionary containing the\n        key/value pair of the items you're creating on the parent\n        object. Defaults to empty dict which will create a single\n        item with default values.\n\n    ## Returns\n    A Record object or list of Record objects created\n    from data created in NetBox.\n    \"\"\"\n    data = data or {}\n    req = Request(**self.request_kwargs).post(data)\n    if self.custom_return:\n        if isinstance(req, list):\n            return [\n                self.custom_return(\n                    req_item, self.parent_obj.endpoint.api, self.parent_obj.endpoint\n                )\n                for req_item in req\n            ]\n        else:\n            return self.custom_return(\n                req, self.parent_obj.endpoint.api, self.parent_obj.endpoint\n            )\n    return req\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.DetailEndpoint.list","title":"<code>list(self, **kwargs)</code>","text":"<p>The view operation for a detail endpoint.</p> <p>Returns the response from NetBox for a detail endpoint.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.DetailEndpoint.list--parameters","title":"Parameters","text":"<ul> <li>kwargs: Key/value pairs that get converted into URL     parameters when passed to the endpoint.     E.g. <code>.list(method='get_facts')</code> would be converted to     <code>.../?method=get_facts</code>.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.DetailEndpoint.list--returns","title":"Returns","text":"<p>A Record object or list of Record objects created from data retrieved from NetBox.</p> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def list(self, **kwargs):\n    \"\"\"The view operation for a detail endpoint.\n\n    Returns the response from NetBox for a detail endpoint.\n\n    ## Parameters\n\n    * **kwargs**: Key/value pairs that get converted into URL\n        parameters when passed to the endpoint.\n        E.g. `.list(method='get_facts')` would be converted to\n        `.../?method=get_facts`.\n\n    ## Returns\n    A Record object or list of Record objects created\n    from data retrieved from NetBox.\n    \"\"\"\n    req = Request(**self.request_kwargs).get(add_params=kwargs)\n\n    if self.custom_return:\n        return [\n            self.custom_return(\n                i, self.parent_obj.endpoint.api, self.parent_obj.endpoint\n            )\n            for i in req\n        ]\n    return req\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will walk you through the basics of using pyNetBox to interact with NetBox.</p>"},{"location":"getting-started/#basic-connection","title":"Basic Connection","text":"<p>First, import pynetbox and create an API connection:</p> <pre><code>import pynetbox\n\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n)\n</code></pre>"},{"location":"getting-started/#connection-parameters","title":"Connection Parameters","text":"<p>The <code>api()</code> method accepts several parameters:</p> <ul> <li>url (required): The base URL of your NetBox instance</li> <li>token (optional): API authentication token (required for write operations)</li> <li>threading (optional): Enable multithreaded requests (default: <code>False</code>)</li> <li>strict_filters (optional): Enable filter validation (default: <code>False</code>)</li> </ul> <pre><code>nb = pynetbox.api(\n    'http://localhost:8000',\n    token='your-token-here',\n    threading=True,\n    strict_filters=True\n)\n</code></pre>"},{"location":"getting-started/#understanding-the-api-structure","title":"Understanding the API Structure","text":"<p>PyNetBox mirrors NetBox's app structure. NetBox apps become attributes of the API object:</p> <pre><code>nb.dcim      # Data Center Infrastructure Management\nnb.ipam      # IP Address Management\nnb.circuits  # Circuit management\nnb.virtualization  # Virtual machines and clusters\nnb.tenancy   # Tenants and contacts\nnb.extras    # Tags, custom fields, etc.\nnb.users     # Users and permissions\nnb.wireless  # Wireless LANs and links\nnb.core      # Core objects (data sources, jobs)\nnb.vpn       # VPN tunnels and terminations\n</code></pre> <p>Each app has endpoints that correspond to NetBox's API endpoints:</p> <pre><code>nb.dcim.devices\nnb.dcim.sites\nnb.dcim.racks\nnb.ipam.ip_addresses\nnb.ipam.prefixes\n# ... and so on\n</code></pre>"},{"location":"getting-started/#querying-data","title":"Querying Data","text":""},{"location":"getting-started/#getting-all-objects","title":"Getting All Objects","text":"<p>Use <code>.all()</code> to retrieve all objects from an endpoint:</p> <pre><code># Get all devices\ndevices = nb.dcim.devices.all()\nfor device in devices:\n    print(device.name)\n</code></pre> <p>Generator Objects</p> <p>The <code>.all()</code> and <code>.filter()</code> methods return generators that can only be iterated once. To iterate multiple times, wrap the result in a <code>list()</code>:</p> <pre><code>devices = list(nb.dcim.devices.all())\n</code></pre>"},{"location":"getting-started/#filtering-objects","title":"Filtering Objects","text":"<p>Use <code>.filter()</code> to query specific objects:</p> <pre><code># Get all devices with a specific role\nleaf_switches = nb.dcim.devices.filter(role='leaf-switch')\n\n# Multiple filters\ndevices = nb.dcim.devices.filter(\n    site='headquarters',\n    status='active',\n    role='access-switch'\n)\n\n# Filter by custom fields\ndevices = nb.dcim.devices.filter(cf_environment='production')\n</code></pre>"},{"location":"getting-started/#getting-a-single-object","title":"Getting a Single Object","text":"<p>Use <code>.get()</code> to retrieve a specific object:</p> <pre><code># Get by ID\ndevice = nb.dcim.devices.get(1)\n\n# Get by name\ndevice = nb.dcim.devices.get(name='spine1')\n\n# Get returns None if not found\ndevice = nb.dcim.devices.get(name='nonexistent')\nif device is None:\n    print(\"Device not found\")\n</code></pre>"},{"location":"getting-started/#working-with-objects","title":"Working with Objects","text":""},{"location":"getting-started/#accessing-attributes","title":"Accessing Attributes","text":"<p>Objects return attributes as properties:</p> <pre><code>device = nb.dcim.devices.get(1)\nprint(device.name)\nprint(device.serial)\nprint(device.device_type)\nprint(device.site.name)  # Nested objects\n</code></pre>"},{"location":"getting-started/#checking-available-attributes","title":"Checking Available Attributes","text":"<pre><code>device = nb.dcim.devices.get(1)\n\n# Convert to dict to see all attributes\nprint(dict(device))\n\n# Or access the raw data\nprint(device.serialize())\n</code></pre>"},{"location":"getting-started/#creating-objects","title":"Creating Objects","text":"<p>Use <code>.create()</code> to create new objects:</p> <pre><code># Create a new site\nnew_site = nb.dcim.sites.create(\n    name='new-datacenter',\n    slug='new-datacenter',\n    status='planned'\n)\n\n# Create a device\nnew_device = nb.dcim.devices.create(\n    name='new-switch',\n    device_type=1,  # Can use ID\n    site=new_site.id,  # Or reference the created object\n    device_role=5\n)\n\n# Create with nested data\nnew_ip = nb.ipam.ip_addresses.create(\n    address='10.0.0.1/24',\n    status='active',\n    assigned_object_type='dcim.interface',\n    assigned_object_id=123\n)\n</code></pre>"},{"location":"getting-started/#updating-objects","title":"Updating Objects","text":"<p>There are two ways to update objects:</p>"},{"location":"getting-started/#method-1-update-and-save","title":"Method 1: Update and Save","text":"<pre><code>device = nb.dcim.devices.get(1)\ndevice.serial = 'ABC123'\ndevice.asset_tag = 'ASSET001'\ndevice.save()\n</code></pre>"},{"location":"getting-started/#method-2-using-update","title":"Method 2: Using Update","text":"<pre><code>device = nb.dcim.devices.get(1)\ndevice.update({\n    'serial': 'ABC123',\n    'asset_tag': 'ASSET001'\n})\n</code></pre>"},{"location":"getting-started/#deleting-objects","title":"Deleting Objects","text":"<p>Use <code>.delete()</code> to remove objects:</p> <pre><code>device = nb.dcim.devices.get(1)\ndevice.delete()\n\n# Or delete directly by ID\nnb.dcim.devices.delete(1)\n</code></pre>"},{"location":"getting-started/#working-with-choices","title":"Working with Choices","text":"<p>Get available choices for choice fields:</p> <pre><code># Get all status choices for devices\nstatuses = nb.dcim.devices.choices()\nprint(statuses['status'])\n\n# Get choices for a specific field\ninterface_types = nb.dcim.interfaces.choices()\nprint(interface_types['type'])\n</code></pre>"},{"location":"getting-started/#pagination","title":"Pagination","text":"<p>NetBox paginates results by default. PyNetBox handles pagination automatically:</p> <pre><code># This will automatically fetch all pages\ndevices = nb.dcim.devices.all()\n\n# You can also limit results\ndevices = nb.dcim.devices.filter(limit=10)\n</code></pre>"},{"location":"getting-started/#error-handling","title":"Error Handling","text":"<pre><code>from pynetbox.core.query import RequestError, ContentError\n\ntry:\n    device = nb.dcim.devices.create(\n        name='test-device',\n        device_type=1,\n        site=1,\n        device_role=1\n    )\nexcept RequestError as e:\n    print(f\"Request failed: {e}\")\nexcept ContentError as e:\n    print(f\"Content error: {e}\")\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Review the API Reference for detailed documentation on core classes</li> <li>Learn about Threading for faster queries</li> <li>Explore Filter Validation for safer queries</li> <li>Review special methods documentation:</li> <li>DCIM Special Methods</li> <li>IPAM Special Methods</li> <li>Virtualization Special Methods</li> <li>Check out Advanced Topics for custom sessions and branching</li> <li>Refer to NetBox API Documentation for standard CRUD operations</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python: 3.10 or higher</li> <li>NetBox: 3.3 or higher (for pyNetBox 6.7+)</li> <li>Dependencies:</li> <li><code>requests&gt;=2.20.0,&lt;3.0</code></li> <li><code>packaging</code></li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#install-from-pypi-recommended","title":"Install from PyPI (Recommended)","text":"<p>The easiest way to install pyNetBox is using pip:</p> <pre><code>pip install pynetbox\n</code></pre>"},{"location":"installation/#install-from-source","title":"Install from Source","text":"<p>If you need the latest development version or want to contribute:</p> <pre><code># Clone the repository\ngit clone https://github.com/netbox-community/pynetbox.git\ncd pynetbox\n\n# Install in development mode\npip install -e .\n\n# Or install directly\npython setup.py install\n</code></pre>"},{"location":"installation/#using-a-virtual-environment-recommended","title":"Using a Virtual Environment (Recommended)","text":"<p>It's recommended to use a virtual environment to isolate pyNetBox dependencies:</p> <pre><code># Create a virtual environment\npython3 -m venv venv\n\n# Activate it (Linux/macOS)\nsource venv/bin/activate\n\n# Activate it (Windows)\nvenv\\Scripts\\activate\n\n# Install pynetbox\npip install pynetbox\n</code></pre>"},{"location":"installation/#verifying-installation","title":"Verifying Installation","text":"<p>After installation, verify pyNetBox is installed correctly:</p> <pre><code>import pynetbox\nprint(pynetbox.version)\n</code></pre> <p>You can also test connectivity to your NetBox instance:</p> <pre><code>import pynetbox\n\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='your-api-token-here'\n)\n\n# Check NetBox version\nprint(nb.version)\n\n# Check API status\nprint(nb.status())\n</code></pre>"},{"location":"installation/#upgrading","title":"Upgrading","text":"<p>To upgrade to the latest version:</p> <pre><code>pip install --upgrade pynetbox\n</code></pre> <p>To upgrade to a specific version:</p> <pre><code>pip install pynetbox==7.6.0\n</code></pre>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>If you're planning to develop or contribute to pyNetBox:</p> <pre><code># Clone the repository\ngit clone https://github.com/netbox-community/pynetbox.git\ncd pynetbox\n\n# Create and activate virtual environment\npython3 -m venv venv\nsource venv/bin/activate\n\n# Install development dependencies\npip install -r requirements.txt\npip install -r requirements-dev.txt\n\n# Install in editable mode\npip install -e .\n</code></pre>"},{"location":"installation/#docker-setup-for-testing","title":"Docker Setup for Testing","text":"<p>The test suite requires Docker for integration tests:</p> <pre><code># Ensure Docker is installed and running\ndocker --version\n\n# Run the test suite\npytest\n</code></pre> <p>For more information on running tests, see the Development Guide.</p>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Read the Getting Started Guide for basic usage</li> <li>Explore the API Reference for detailed documentation</li> <li>Check the Advanced Topics for custom configurations</li> </ul>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#version-761-january-28-2026","title":"Version 7.6.1 (January 28, 2026)","text":""},{"location":"release-notes/#enhancements","title":"Enhancements","text":"<ul> <li>#726 - Use <code>dict</code> instead of <code>OrderedDict</code> in Record serialization</li> </ul>"},{"location":"release-notes/#new-features","title":"New Features","text":"<ul> <li>#434 - Add cable path tracing support for front ports, rear ports, and virtual circuit terminations</li> </ul>"},{"location":"release-notes/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>#586 - Update internal object state after save operations to prevent attribute reset issues</li> </ul>"},{"location":"release-notes/#version-760-january-9-2026","title":"Version 7.6.0 (January 9, 2026)","text":""},{"location":"release-notes/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>ObjectChange moved to <code>core</code> module for NetBox 4.1.0+ compatibility</li> <li>Previously located in <code>extras.object_changes</code></li> <li>Now accessible via <code>nb.core.object_changes</code></li> </ul>"},{"location":"release-notes/#new-features_1","title":"New Features","text":"<ul> <li>Support for v2 Tokens introduced in NetBox 4.5.0</li> <li>Enhanced token management capabilities</li> </ul>"},{"location":"release-notes/#enhancements_1","title":"Enhancements","text":"<ul> <li>Added SVG support for Rack Elevation endpoint</li> <li>Rack elevation diagrams can now be rendered as SVG</li> <li>Access via <code>rack.elevation.list(render='svg')</code></li> </ul>"},{"location":"release-notes/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Fixed token authentication when retrieving NetBox version</li> <li>Prevents 403 errors during version checks</li> <li>Token now properly included in version API requests</li> </ul>"},{"location":"release-notes/#compatibility","title":"Compatibility","text":"<ul> <li>Supports NetBox 4.5</li> </ul>"},{"location":"release-notes/#version-750-may-20-2024","title":"Version 7.5.0 (May 20, 2024)","text":""},{"location":"release-notes/#enhancements_2","title":"Enhancements","text":"<ul> <li>Expanded cable trace functionality to include:</li> <li>CircuitTerminations</li> <li>ConsolePorts</li> <li>ConsoleServerPorts</li> <li>PowerOutlets</li> <li>PowerPorts</li> <li>Added built-in function to activate a branch</li> <li>Use <code>nb.activate_branch()</code> context manager for NetBox branching plugin</li> </ul>"},{"location":"release-notes/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>Fixed choices returned when API tokens have PUT but not POST permissions</li> <li>Fixed <code>nb.version</code> property when using OIDC proxy authentication</li> </ul>"},{"location":"release-notes/#compatibility_1","title":"Compatibility","text":"<ul> <li>Supports NetBox 4.1, 4.2, 4.3, 4.4</li> </ul>"},{"location":"release-notes/#version-741-october-25-2024","title":"Version 7.4.1 (October 25, 2024)","text":""},{"location":"release-notes/#security","title":"Security","text":"<ul> <li>Updated <code>requests</code> and <code>urllib3</code> Python libraries to address security vulnerabilities</li> <li>No functional changes</li> </ul>"},{"location":"release-notes/#version-740-august-8-2024","title":"Version 7.4.0 (August 8, 2024)","text":""},{"location":"release-notes/#enhancements_3","title":"Enhancements","text":"<ul> <li>Added initial NetBox 4.0 support</li> <li>Added Python 3.12 support</li> </ul>"},{"location":"release-notes/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>Fixed complex custom_fields insertion failures</li> <li>Replaced <code>None</code> with <code>'null'</code> in query parameters</li> <li>Corrected connected endpoints behavior</li> </ul>"},{"location":"release-notes/#testing","title":"Testing","text":"<ul> <li>Removed Python 3.8 and 3.9 from test matrix</li> <li>Added Python 3.12 to CI/CD pipeline</li> </ul>"},{"location":"release-notes/#compatibility_2","title":"Compatibility","text":"<ul> <li>Supports NetBox 4.0.6+</li> </ul>"},{"location":"release-notes/#version-734-july-2-2024","title":"Version 7.3.4 (July 2, 2024)","text":""},{"location":"release-notes/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>Fixed API version detection for NetBox versions exceeding 4.x</li> <li>Removed linting errors</li> </ul>"},{"location":"release-notes/#testing_1","title":"Testing","text":"<ul> <li>Dropped NetBox 3.3 from test matrix</li> <li>Focus on NetBox 4.x support</li> </ul>"},{"location":"release-notes/#version-733-january-5-2024","title":"Version 7.3.3 (January 5, 2024)","text":""},{"location":"release-notes/#fixes","title":"Fixes","text":"<ul> <li>PyPI release fix</li> <li>No functional changes</li> </ul>"},{"location":"release-notes/#version-732-january-4-2024","title":"Version 7.3.2 (January 4, 2024)","text":""},{"location":"release-notes/#fixes_1","title":"Fixes","text":"<ul> <li>Fixed setup.py for new publish workflow</li> <li>No functional changes</li> </ul>"},{"location":"release-notes/#version-731-january-4-2024","title":"Version 7.3.1 (January 4, 2024)","text":""},{"location":"release-notes/#fixes_2","title":"Fixes","text":"<ul> <li>Updated PyPI publish workflow</li> <li>No functional changes</li> </ul>"},{"location":"release-notes/#version-730-january-3-2024","title":"Version 7.3.0 (January 3, 2024)","text":""},{"location":"release-notes/#new-features_2","title":"New Features","text":"<ul> <li>Added NetBox v3.7 support</li> </ul>"},{"location":"release-notes/#dependencies","title":"Dependencies","text":"<ul> <li>Added <code>pyyaml</code> dependency</li> </ul>"},{"location":"release-notes/#testing_2","title":"Testing","text":"<ul> <li>Updated test suite for NetBox 3.7 compatibility</li> </ul>"},{"location":"release-notes/#compatibility_3","title":"Compatibility","text":"<ul> <li>Supports NetBox 3.7</li> </ul>"},{"location":"release-notes/#version-720-september-7-2023","title":"Version 7.2.0 (September 7, 2023)","text":""},{"location":"release-notes/#new-features_3","title":"New Features","text":"<ul> <li>Added NetBox v3.6 support</li> </ul>"},{"location":"release-notes/#compatibility_4","title":"Compatibility","text":"<ul> <li>Supports NetBox 3.6</li> </ul>"},{"location":"release-notes/#version-710-august-2023","title":"Version 7.1.0 (August 2023)","text":""},{"location":"release-notes/#code-quality","title":"Code Quality","text":"<ul> <li>Lint fixes and code cleanup</li> <li>Improved code formatting consistency</li> </ul>"},{"location":"release-notes/#compatibility_5","title":"Compatibility","text":"<ul> <li>Supports NetBox 3.5</li> </ul>"},{"location":"release-notes/#version-701-june-2023","title":"Version 7.0.1 (June 2023)","text":""},{"location":"release-notes/#enhancements_4","title":"Enhancements","text":"<ul> <li>Updated code formatting</li> <li>Documentation improvements</li> </ul>"},{"location":"release-notes/#version-700-june-2023","title":"Version 7.0.0 (June 2023)","text":""},{"location":"release-notes/#breaking-changes_1","title":"Breaking Changes","text":"<ul> <li>Minimum NetBox version: 3.3+</li> <li>Removed support for NetBox versions below 3.3</li> </ul>"},{"location":"release-notes/#new-features_4","title":"New Features","text":"<ul> <li>Full NetBox 3.3 API support</li> <li>Updated test suite for NetBox 3.3</li> </ul>"},{"location":"release-notes/#testing_3","title":"Testing","text":"<ul> <li>Completely overhauled test scripts</li> <li>Updated test settings for NetBox 3.3 compatibility</li> <li>Improved integration test coverage</li> </ul>"},{"location":"release-notes/#compatibility_6","title":"Compatibility","text":"<ul> <li>NetBox 3.3+ required</li> <li>Python 3.8+ required</li> </ul>"},{"location":"release-notes/#version-67x-and-earlier","title":"Version 6.7.x and Earlier","text":"<p>For release notes for versions 6.7 and earlier, please refer to the GitHub Releases page.</p> <p>Key highlights from earlier versions:</p>"},{"location":"release-notes/#version-67-last-pre-70-release","title":"Version 6.7 (Last pre-7.0 release)","text":"<ul> <li>Last version to support NetBox &lt; 3.3</li> <li>Python 3.7+ support</li> </ul>"},{"location":"release-notes/#version-66","title":"Version 6.6","text":"<ul> <li>Custom error pickling fixes</li> <li>VLAN str improvements</li> <li>VirtualChassis enhancements</li> </ul>"},{"location":"release-notes/#version-65","title":"Version 6.5","text":"<ul> <li>Added available-vlans support for VLAN groups</li> </ul>"},{"location":"release-notes/#version-64","title":"Version 6.4","text":"<ul> <li>Added Wireless app support</li> <li>Data returned as dict improvements</li> </ul>"},{"location":"release-notes/#version-63","title":"Version 6.3","text":"<ul> <li>Field name lookup improvements</li> <li>Enhanced filtering capabilities</li> </ul>"},{"location":"request/","title":"Request","text":""},{"location":"request/#pynetbox.core.query.RequestError","title":"<code> pynetbox.core.query.RequestError            (Exception)         </code>","text":"<p>Basic Request Exception.</p> <p>More detailed exception that returns the original requests object for inspection. Along with some attributes with specific details from the requests object. If return is json we decode and add it to the message.</p>"},{"location":"request/#pynetbox.core.query.RequestError--examples","title":"Examples","text":"<pre><code>try:\n    nb.dcim.devices.create(name=\"destined-for-failure\")\nexcept pynetbox.RequestError as e:\n    print(e.error)\n</code></pre> Source code in <code>pynetbox/core/query.py</code> <pre><code>class RequestError(Exception):\n    \"\"\"Basic Request Exception.\n\n    More detailed exception that returns the original requests object\n    for inspection. Along with some attributes with specific details\n    from the requests object. If return is json we decode and add it\n    to the message.\n\n    ## Examples\n\n    ```python\n    try:\n        nb.dcim.devices.create(name=\"destined-for-failure\")\n    except pynetbox.RequestError as e:\n        print(e.error)\n    ```\n    \"\"\"\n\n    def __init__(self, req):\n        if req.status_code == 404:\n            self.message = \"The requested url: {} could not be found.\".format(req.url)\n        else:\n            try:\n                self.message = \"The request failed with code {} {}: {}\".format(\n                    req.status_code, req.reason, req.json()\n                )\n            except ValueError:\n                self.message = (\n                    \"The request failed with code {} {} but more specific \"\n                    \"details were not returned in json. Check the NetBox Logs \"\n                    \"or investigate this exception's error attribute.\".format(\n                        req.status_code, req.reason\n                    )\n                )\n\n        super().__init__(self.message)\n        self.req = req\n        self.request_body = req.request.body\n        self.base = req.url\n        self.error = req.text\n\n    def __str__(self):\n        return self.message\n</code></pre>"},{"location":"request/#pynetbox.core.query.ContentError","title":"<code> pynetbox.core.query.ContentError            (Exception)         </code>","text":"<p>Content Exception.</p> <p>If the API URL does not point to a valid NetBox API, the server may return a valid response code, but the content is not json. This exception is raised in those cases.</p> Source code in <code>pynetbox/core/query.py</code> <pre><code>class ContentError(Exception):\n    \"\"\"Content Exception.\n\n    If the API URL does not point to a valid NetBox API, the server may\n    return a valid response code, but the content is not json. This\n    exception is raised in those cases.\n    \"\"\"\n\n    def __init__(self, req):\n        super().__init__(req)\n        self.req = req\n        self.request_body = req.request.body\n        self.base = req.url\n        self.error = (\n            \"The server returned invalid (non-json) data. Maybe not a NetBox server?\"\n        )\n\n    def __str__(self):\n        return self.error\n</code></pre>"},{"location":"request/#pynetbox.core.query.AllocationError","title":"<code> pynetbox.core.query.AllocationError            (Exception)         </code>","text":"<p>Allocation Exception.</p> <p>Used with available-ips/available-prefixes when there is no room for allocation and NetBox returns 409 Conflict.</p> Source code in <code>pynetbox/core/query.py</code> <pre><code>class AllocationError(Exception):\n    \"\"\"Allocation Exception.\n\n    Used with available-ips/available-prefixes when there is no\n    room for allocation and NetBox returns 409 Conflict.\n    \"\"\"\n\n    def __init__(self, req):\n        super().__init__(req)\n        self.req = req\n        self.request_body = req.request.body\n        self.base = req.url\n        self.error = \"The requested allocation could not be fulfilled.\"\n\n    def __str__(self):\n        return self.error\n</code></pre>"},{"location":"response/","title":"Response","text":""},{"location":"response/#pynetbox.core.response.Record","title":"<code> pynetbox.core.response.Record        </code>","text":"<p>Create Python objects from NetBox API responses.</p> <p>Creates an object from a NetBox response passed as <code>values</code>. Nested dicts that represent other endpoints are also turned into Record objects. All fields are then assigned to the object's attributes. If a missing attr is requested (e.g. requesting a field that's only present on a full response on a Record made from a nested response) then pynetbox will make a request for the full object and return the requested value.</p>"},{"location":"response/#pynetbox.core.response.Record--examples","title":"Examples","text":"<p>Default representation of the object is usually its name:</p> <pre><code>x = nb.dcim.devices.get(1)\nx\n# test1-switch1\n</code></pre> <p>Querying a string field:</p> <pre><code>x = nb.dcim.devices.get(1)\nx.serial\n# 'ABC123'\n</code></pre> <p>Querying a field on a nested object:</p> <pre><code>x = nb.dcim.devices.get(1)\nx.device_type.model\n# 'QFX5100-24Q'\n</code></pre> <p>Casting the object as a dictionary:</p> <pre><code>from pprint import pprint\npprint(dict(x))\n{\n    'asset_tag': None,\n    'cluster': None,\n    'comments': '',\n    'config_context': {},\n    'created': '2018-04-01',\n    'custom_fields': {},\n    'role': {\n        'id': 1,\n        'name': 'Test Switch',\n        'slug': 'test-switch',\n        'url': 'http://localhost:8000/api/dcim/device-roles/1/'\n    },\n    'device_type': {...},\n    'display_name': 'test1-switch1',\n    'face': {'label': 'Rear', 'value': 1},\n    'id': 1,\n    'name': 'test1-switch1',\n    'parent_device': None,\n    'platform': {...},\n    'position': 1,\n    'primary_ip': {\n        'address': '192.0.2.1/24',\n        'family': 4,\n        'id': 1,\n        'url': 'http://localhost:8000/api/ipam/ip-addresses/1/'\n    },\n    'primary_ip4': {...},\n    'primary_ip6': None,\n    'rack': {\n        'display_name': 'Test Rack',\n        'id': 1,\n        'name': 'Test Rack',\n        'url': 'http://localhost:8000/api/dcim/racks/1/'\n    },\n    'site': {\n        'id': 1,\n        'name': 'TEST',\n        'slug': 'TEST',\n        'url': 'http://localhost:8000/api/dcim/sites/1/'\n    },\n    'status': {'label': 'Active', 'value': 1},\n    'tags': [],\n    'tenant': None,\n    'vc_position': None,\n    'vc_priority': None,\n    'virtual_chassis': None\n}\n</code></pre> <p>Iterating over a Record object:</p> <pre><code>for i in x:\n    print(i)\n\n# ('id', 1)\n# ('name', 'test1-switch1')\n# ('display_name', 'test1-switch1')\n</code></pre> Source code in <code>pynetbox/core/response.py</code> <pre><code>class Record:\n    \"\"\"Create Python objects from NetBox API responses.\n\n    Creates an object from a NetBox response passed as `values`.\n    Nested dicts that represent other endpoints are also turned\n    into Record objects. All fields are then assigned to the\n    object's attributes. If a missing attr is requested\n    (e.g. requesting a field that's only present on a full response on\n    a Record made from a nested response) then pynetbox will make a\n    request for the full object and return the requested value.\n\n    ## Examples\n\n    Default representation of the object is usually its name:\n\n    ```python\n    x = nb.dcim.devices.get(1)\n    x\n    # test1-switch1\n    ```\n\n    Querying a string field:\n\n    ```python\n    x = nb.dcim.devices.get(1)\n    x.serial\n    # 'ABC123'\n    ```\n\n    Querying a field on a nested object:\n\n    ```python\n    x = nb.dcim.devices.get(1)\n    x.device_type.model\n    # 'QFX5100-24Q'\n    ```\n\n    Casting the object as a dictionary:\n\n    ```python\n    from pprint import pprint\n    pprint(dict(x))\n    {\n        'asset_tag': None,\n        'cluster': None,\n        'comments': '',\n        'config_context': {},\n        'created': '2018-04-01',\n        'custom_fields': {},\n        'role': {\n            'id': 1,\n            'name': 'Test Switch',\n            'slug': 'test-switch',\n            'url': 'http://localhost:8000/api/dcim/device-roles/1/'\n        },\n        'device_type': {...},\n        'display_name': 'test1-switch1',\n        'face': {'label': 'Rear', 'value': 1},\n        'id': 1,\n        'name': 'test1-switch1',\n        'parent_device': None,\n        'platform': {...},\n        'position': 1,\n        'primary_ip': {\n            'address': '192.0.2.1/24',\n            'family': 4,\n            'id': 1,\n            'url': 'http://localhost:8000/api/ipam/ip-addresses/1/'\n        },\n        'primary_ip4': {...},\n        'primary_ip6': None,\n        'rack': {\n            'display_name': 'Test Rack',\n            'id': 1,\n            'name': 'Test Rack',\n            'url': 'http://localhost:8000/api/dcim/racks/1/'\n        },\n        'site': {\n            'id': 1,\n            'name': 'TEST',\n            'slug': 'TEST',\n            'url': 'http://localhost:8000/api/dcim/sites/1/'\n        },\n        'status': {'label': 'Active', 'value': 1},\n        'tags': [],\n        'tenant': None,\n        'vc_position': None,\n        'vc_priority': None,\n        'virtual_chassis': None\n    }\n    ```\n\n    Iterating over a Record object:\n\n    ```python\n    for i in x:\n        print(i)\n\n    # ('id', 1)\n    # ('name', 'test1-switch1')\n    # ('display_name', 'test1-switch1')\n    ```\n    \"\"\"\n\n    url = None\n\n    def __init__(self, values, api, endpoint):\n        self.has_details = False\n        self._full_cache = []\n        self._init_cache = []\n        self.api = api\n        self.default_ret = Record\n        self.endpoint = (\n            self._endpoint_from_url(values[\"url\"])\n            if values and \"url\" in values and values[\"url\"]\n            else endpoint\n        )\n        if values:\n            self._parse_values(values)\n\n    def __getattr__(self, k):\n        \"\"\"Default behavior for missing attrs.\n\n        We'll call `full_details()` if we're asked for an attribute\n        we don't have.\n\n        In order to prevent non-explicit behavior,`k='keys'` is\n        excluded because casting to dict() calls this attr.\n        \"\"\"\n        if self.url:\n            if self.has_details is False and k != \"keys\":\n                if self.full_details():\n                    ret = getattr(self, k, None)\n                    if ret or hasattr(self, k):\n                        return ret\n\n        raise AttributeError('object has no attribute \"{}\"'.format(k))\n\n    def __iter__(self):\n        for i in dict(self._init_cache):\n            cur_attr = getattr(self, i)\n            if isinstance(cur_attr, Record):\n                yield i, dict(cur_attr)\n            elif isinstance(cur_attr, list) and all(\n                isinstance(i, (Record, GenericListObject)) for i in cur_attr\n            ):\n                yield i, [dict(x) for x in cur_attr]\n            else:\n                yield i, cur_attr\n\n    def __getitem__(self, k):\n        return dict(self)[k]\n\n    def __str__(self):\n        return (\n            getattr(self, \"name\", None)\n            or getattr(self, \"label\", None)\n            or getattr(self, \"display\", None)\n            or \"\"\n        )\n\n    def __repr__(self):\n        return str(self)\n\n    def __getstate__(self):\n        return self.__dict__\n\n    def __setstate__(self, d):\n        self.__dict__.update(d)\n\n    def __key__(self):\n        if hasattr(self, \"id\"):\n            return (self.endpoint.name, self.id)\n        else:\n            return self.endpoint.name\n\n    def __hash__(self):\n        return hash(self.__key__())\n\n    def __eq__(self, other):\n        if isinstance(other, Record):\n            return self.__key__() == other.__key__()\n        return NotImplemented\n\n    def _extract_app_endpoint(self, url):\n        \"\"\"Extract app/endpoint from a NetBox API URL.\n\n        Extracts the app and endpoint portion from a URL like:\n            https://netbox/api/dcim/rear-ports/12761/\n        Returns:\n            String like \"dcim/rear-ports\"\n        \"\"\"\n        app_endpoint = \"/\".join(\n            urlsplit(url).path[len(urlsplit(self.api.base_url).path) :].split(\"/\")[1:3]\n        )\n        return app_endpoint\n\n    def _get_obj_class(self, url):\n        \"\"\"Map API URL to corresponding Record class for cable tracing.\n\n        Used by TraceableRecord and PathableRecord to deserialize objects\n        encountered in cable trace/path responses.\n        \"\"\"\n        # Import here to avoid circular dependency\n        from pynetbox.models.circuits import CircuitTerminations\n        from pynetbox.models.dcim import (\n            Cables,\n            ConsolePorts,\n            ConsoleServerPorts,\n            FrontPorts,\n            Interfaces,\n            PowerFeeds,\n            PowerOutlets,\n            PowerPorts,\n            RearPorts,\n        )\n\n        uri_to_obj_class_map = {\n            \"circuits/circuit-terminations\": CircuitTerminations,\n            \"dcim/cables\": Cables,\n            \"dcim/console-ports\": ConsolePorts,\n            \"dcim/console-server-ports\": ConsoleServerPorts,\n            \"dcim/front-ports\": FrontPorts,\n            \"dcim/interfaces\": Interfaces,\n            \"dcim/power-feeds\": PowerFeeds,\n            \"dcim/power-outlets\": PowerOutlets,\n            \"dcim/power-ports\": PowerPorts,\n            \"dcim/rear-ports\": RearPorts,\n        }\n\n        app_endpoint = self._extract_app_endpoint(url)\n        return uri_to_obj_class_map.get(app_endpoint, Record)\n\n    def _add_cache(self, item):\n        key, value = item\n        self._init_cache.append((key, get_return(value)))\n\n    def _parse_values(self, values):\n        \"\"\"Parses values init arg.\n\n        Parses values dict at init and sets object attributes with the\n        values within.\n        \"\"\"\n\n        def generic_list_parser(key_name, list_item):\n            from pynetbox.models.mapper import CONTENT_TYPE_MAPPER\n\n            if (\n                isinstance(list_item, dict)\n                and \"object_type\" in list_item\n                and \"object\" in list_item\n            ):\n                lookup = list_item[\"object_type\"]\n                if model := CONTENT_TYPE_MAPPER.get(lookup, None):\n                    record = model(list_item[\"object\"], self.api, self.endpoint)\n                    return GenericListObject(record)\n\n            return list_item\n\n        def list_parser(key_name, list_item):\n            if isinstance(list_item, dict):\n                lookup = getattr(self.__class__, key_name, None)\n                if not isinstance(lookup, list):\n                    # This is *list_parser*, so if the custom model field is not\n                    # a list (or is not defined), just return the default model\n                    return self.default_ret(list_item, self.api, self.endpoint)\n                else:\n                    model = lookup[0]\n                    return model(list_item, self.api, self.endpoint)\n\n            return list_item\n\n        for k, v in values.items():\n            if isinstance(v, dict):\n                lookup = getattr(self.__class__, k, None)\n                if k in [\"custom_fields\", \"local_context_data\"] or hasattr(\n                    lookup, \"_json_field\"\n                ):\n                    self._add_cache((k, copy.deepcopy(v)))\n                    setattr(self, k, v)\n                    continue\n                if lookup:\n                    v = lookup(v, self.api, self.endpoint)\n                else:\n                    v = self.default_ret(v, self.api, self.endpoint)\n                self._add_cache((k, v))\n\n            elif isinstance(v, list):\n                # check if GFK\n                if len(v) and isinstance(v[0], dict) and \"object_type\" in v[0]:\n                    v = [generic_list_parser(k, i) for i in v]\n                    to_cache = [i.serialize() for i in v]\n                elif k == \"constraints\":\n                    # Permissions constraints can be either dict or list\n                    to_cache = copy.deepcopy(v)\n                else:\n                    v = [list_parser(k, i) for i in v]\n                    to_cache = list(v)\n                self._add_cache((k, to_cache))\n\n            else:\n                self._add_cache((k, v))\n            setattr(self, k, v)\n\n    def _endpoint_from_url(self, url):\n        url_path = urlsplit(url).path\n        base_url_path_parts = urlsplit(self.api.base_url).path.split(\"/\")\n        if len(base_url_path_parts) &gt; 2:\n            # There are some extra directories in the path, remove them from url\n            extra_path = \"/\".join(base_url_path_parts[:-1])\n            url_path = url_path[len(extra_path) :]\n        split_url_path = url_path.split(\"/\")\n        if split_url_path[2] == \"plugins\":\n            app = \"plugins/{}\".format(split_url_path[3])\n            name = split_url_path[4]\n        else:\n            app, name = split_url_path[2:4]\n        return getattr(pynetbox.core.app.App(self.api, app), name)\n\n    def full_details(self):\n        \"\"\"Queries the hyperlinked endpoint if 'url' is defined.\n\n        This method will populate the attributes from the detail\n        endpoint when it's called. Sets the class-level `has_details`\n        attribute when it's called to prevent being called more\n        than once.\n\n        :returns: True\n        \"\"\"\n        if self.url:\n            req = Request(\n                base=self.url,\n                token=self.api.token,\n                http_session=self.api.http_session,\n            )\n            self._parse_values(next(req.get()))\n            self.has_details = True\n            return True\n        return False\n\n    def serialize(self, nested=False, init=False):\n        \"\"\"Serializes an object\n\n        Pulls all the attributes in an object and creates a dict that\n        can be turned into the json that netbox is expecting.\n\n        If an attribute's value is a ``Record`` type it's replaced with\n        the ``id`` field of that object.\n\n\n        .. note::\n\n            Using this to get a dictionary representation of the record\n            is discouraged. It's probably better to cast to dict()\n            instead. See Record docstring for example.\n\n        :returns: dict.\n        \"\"\"\n        if nested:\n            return get_return(self)\n\n        if init:\n            init_vals = dict(self._init_cache)\n\n        ret = {}\n\n        for i in dict(self):\n            current_val = getattr(self, i) if not init else init_vals.get(i)\n            if i == \"custom_fields\":\n                ret[i] = flatten_custom(current_val)\n            else:\n                if isinstance(current_val, Record):\n                    current_val = getattr(current_val, \"serialize\")(nested=True)\n\n                if isinstance(current_val, list):\n                    serialized_list = []\n                    for v in current_val:\n                        if isinstance(v, GenericListObject):\n                            v = v.serialize()\n                        elif isinstance(v, Record):\n                            v = v.id\n                        serialized_list.append(v)\n                    current_val = serialized_list\n                    if i in LIST_AS_SET and (\n                        all([isinstance(v, str) for v in current_val])\n                        or all([isinstance(v, int) for v in current_val])\n                    ):\n                        current_val = list(dict.fromkeys(current_val))\n                ret[i] = current_val\n\n        return ret\n\n    def _diff(self):\n        def fmt_dict(k, v):\n            if isinstance(v, dict):\n                return k, Hashabledict(v)\n            if isinstance(v, list):\n                return k, \",\".join(map(str, v))\n            return k, v\n\n        current = Hashabledict({fmt_dict(k, v) for k, v in self.serialize().items()})\n        init = Hashabledict(\n            {fmt_dict(k, v) for k, v in self.serialize(init=True).items()}\n        )\n        return set([i[0] for i in set(current.items()) ^ set(init.items())])\n\n    def updates(self):\n        \"\"\"Compiles changes for an existing object into a dict.\n\n        Takes a diff between the objects current state and its state at init\n        and returns them as a dictionary, which will be empty if no changes.\n\n        :returns: dict.\n        :example:\n\n        &gt;&gt;&gt; x = nb.dcim.devices.get(name='test1-a3-tor1b')\n        &gt;&gt;&gt; x.serial\n        ''\n        &gt;&gt;&gt; x.serial = '1234'\n        &gt;&gt;&gt; x.updates()\n        {'serial': '1234'}\n        &gt;&gt;&gt;\n        \"\"\"\n        if self.id:\n            diff = self._diff()\n            if diff:\n                serialized = self.serialize()\n                return {i: serialized[i] for i in diff}\n        return {}\n\n    def save(self):\n        \"\"\"Saves changes to an existing object.\n\n        Takes a diff between the objects current state and its state at init\n        and sends them as a dictionary to Request.patch().\n\n        :returns: True if PATCH request was successful.\n        :example:\n\n        &gt;&gt;&gt; x = nb.dcim.devices.get(name='test1-a3-tor1b')\n        &gt;&gt;&gt; x.serial\n        ''\n        &gt;&gt;&gt; x.serial = '1234'\n        &gt;&gt;&gt; x.save()\n        True\n        &gt;&gt;&gt;\n        \"\"\"\n        updates = self.updates()\n        if updates:\n            req = Request(\n                key=self.id,\n                base=self.endpoint.url,\n                token=self.api.token,\n                http_session=self.api.http_session,\n            )\n            result = req.patch(updates)\n            if result:\n                # Update object state with response from PATCH to keep cache in sync\n                self._parse_values(result)\n                return True\n        return False\n\n    def update(self, data):\n        \"\"\"Update an object with a dictionary.\n\n        Accepts a dict and uses it to update the record and call save().\n        For nested and choice fields you'd pass an int the same as\n        if you were modifying the attribute and calling save().\n\n        :arg dict data: Dictionary containing the k/v to update the\n            record object with.\n        :returns: True if PATCH request was successful.\n        :example:\n\n        &gt;&gt;&gt; x = nb.dcim.devices.get(1)\n        &gt;&gt;&gt; x.update({\n        ...   \"name\": \"test-switch2\",\n        ...   \"serial\": \"ABC321\",\n        ... })\n        True\n\n        \"\"\"\n\n        for k, v in data.items():\n            setattr(self, k, v)\n        return self.save()\n\n    def delete(self):\n        \"\"\"Deletes an existing object.\n\n        :returns: True if DELETE operation was successful.\n        :example:\n\n        &gt;&gt;&gt; x = nb.dcim.devices.get(name='test1-a3-tor1b')\n        &gt;&gt;&gt; x.delete()\n        True\n        &gt;&gt;&gt;\n        \"\"\"\n        req = Request(\n            key=self.id,\n            base=self.endpoint.url,\n            token=self.api.token,\n            http_session=self.api.http_session,\n        )\n        return True if req.delete() else False\n</code></pre>"},{"location":"response/#pynetbox.core.response.Record.delete","title":"<code>delete(self)</code>","text":"<p>Deletes an existing object.</p> <p>:returns: True if DELETE operation was successful. :example:</p> <p>x = nb.dcim.devices.get(name='test1-a3-tor1b') x.delete() True </p> Source code in <code>pynetbox/core/response.py</code> <pre><code>def delete(self):\n    \"\"\"Deletes an existing object.\n\n    :returns: True if DELETE operation was successful.\n    :example:\n\n    &gt;&gt;&gt; x = nb.dcim.devices.get(name='test1-a3-tor1b')\n    &gt;&gt;&gt; x.delete()\n    True\n    &gt;&gt;&gt;\n    \"\"\"\n    req = Request(\n        key=self.id,\n        base=self.endpoint.url,\n        token=self.api.token,\n        http_session=self.api.http_session,\n    )\n    return True if req.delete() else False\n</code></pre>"},{"location":"response/#pynetbox.core.response.Record.full_details","title":"<code>full_details(self)</code>","text":"<p>Queries the hyperlinked endpoint if 'url' is defined.</p> <p>This method will populate the attributes from the detail endpoint when it's called. Sets the class-level <code>has_details</code> attribute when it's called to prevent being called more than once.</p> <p>:returns: True</p> Source code in <code>pynetbox/core/response.py</code> <pre><code>def full_details(self):\n    \"\"\"Queries the hyperlinked endpoint if 'url' is defined.\n\n    This method will populate the attributes from the detail\n    endpoint when it's called. Sets the class-level `has_details`\n    attribute when it's called to prevent being called more\n    than once.\n\n    :returns: True\n    \"\"\"\n    if self.url:\n        req = Request(\n            base=self.url,\n            token=self.api.token,\n            http_session=self.api.http_session,\n        )\n        self._parse_values(next(req.get()))\n        self.has_details = True\n        return True\n    return False\n</code></pre>"},{"location":"response/#pynetbox.core.response.Record.save","title":"<code>save(self)</code>","text":"<p>Saves changes to an existing object.</p> <p>Takes a diff between the objects current state and its state at init and sends them as a dictionary to Request.patch().</p> <p>:returns: True if PATCH request was successful. :example:</p> <p>x = nb.dcim.devices.get(name='test1-a3-tor1b') x.serial '' x.serial = '1234' x.save() True </p> Source code in <code>pynetbox/core/response.py</code> <pre><code>def save(self):\n    \"\"\"Saves changes to an existing object.\n\n    Takes a diff between the objects current state and its state at init\n    and sends them as a dictionary to Request.patch().\n\n    :returns: True if PATCH request was successful.\n    :example:\n\n    &gt;&gt;&gt; x = nb.dcim.devices.get(name='test1-a3-tor1b')\n    &gt;&gt;&gt; x.serial\n    ''\n    &gt;&gt;&gt; x.serial = '1234'\n    &gt;&gt;&gt; x.save()\n    True\n    &gt;&gt;&gt;\n    \"\"\"\n    updates = self.updates()\n    if updates:\n        req = Request(\n            key=self.id,\n            base=self.endpoint.url,\n            token=self.api.token,\n            http_session=self.api.http_session,\n        )\n        result = req.patch(updates)\n        if result:\n            # Update object state with response from PATCH to keep cache in sync\n            self._parse_values(result)\n            return True\n    return False\n</code></pre>"},{"location":"response/#pynetbox.core.response.Record.serialize","title":"<code>serialize(self, nested=False, init=False)</code>","text":"<p>Serializes an object</p> <p>Pulls all the attributes in an object and creates a dict that can be turned into the json that netbox is expecting.</p> <p>If an attribute's value is a <code>Record</code> type it's replaced with the <code>id</code> field of that object.</p> <p>.. note::</p> <pre><code>Using this to get a dictionary representation of the record\nis discouraged. It's probably better to cast to dict()\ninstead. See Record docstring for example.\n</code></pre> <p>:returns: dict.</p> Source code in <code>pynetbox/core/response.py</code> <pre><code>def serialize(self, nested=False, init=False):\n    \"\"\"Serializes an object\n\n    Pulls all the attributes in an object and creates a dict that\n    can be turned into the json that netbox is expecting.\n\n    If an attribute's value is a ``Record`` type it's replaced with\n    the ``id`` field of that object.\n\n\n    .. note::\n\n        Using this to get a dictionary representation of the record\n        is discouraged. It's probably better to cast to dict()\n        instead. See Record docstring for example.\n\n    :returns: dict.\n    \"\"\"\n    if nested:\n        return get_return(self)\n\n    if init:\n        init_vals = dict(self._init_cache)\n\n    ret = {}\n\n    for i in dict(self):\n        current_val = getattr(self, i) if not init else init_vals.get(i)\n        if i == \"custom_fields\":\n            ret[i] = flatten_custom(current_val)\n        else:\n            if isinstance(current_val, Record):\n                current_val = getattr(current_val, \"serialize\")(nested=True)\n\n            if isinstance(current_val, list):\n                serialized_list = []\n                for v in current_val:\n                    if isinstance(v, GenericListObject):\n                        v = v.serialize()\n                    elif isinstance(v, Record):\n                        v = v.id\n                    serialized_list.append(v)\n                current_val = serialized_list\n                if i in LIST_AS_SET and (\n                    all([isinstance(v, str) for v in current_val])\n                    or all([isinstance(v, int) for v in current_val])\n                ):\n                    current_val = list(dict.fromkeys(current_val))\n            ret[i] = current_val\n\n    return ret\n</code></pre>"},{"location":"response/#pynetbox.core.response.Record.update","title":"<code>update(self, data)</code>","text":"<p>Update an object with a dictionary.</p> <p>Accepts a dict and uses it to update the record and call save(). For nested and choice fields you'd pass an int the same as if you were modifying the attribute and calling save().</p> <p>:arg dict data: Dictionary containing the k/v to update the     record object with. :returns: True if PATCH request was successful. :example:</p> <p>x = nb.dcim.devices.get(1) x.update({ ...   \"name\": \"test-switch2\", ...   \"serial\": \"ABC321\", ... }) True</p> Source code in <code>pynetbox/core/response.py</code> <pre><code>def update(self, data):\n    \"\"\"Update an object with a dictionary.\n\n    Accepts a dict and uses it to update the record and call save().\n    For nested and choice fields you'd pass an int the same as\n    if you were modifying the attribute and calling save().\n\n    :arg dict data: Dictionary containing the k/v to update the\n        record object with.\n    :returns: True if PATCH request was successful.\n    :example:\n\n    &gt;&gt;&gt; x = nb.dcim.devices.get(1)\n    &gt;&gt;&gt; x.update({\n    ...   \"name\": \"test-switch2\",\n    ...   \"serial\": \"ABC321\",\n    ... })\n    True\n\n    \"\"\"\n\n    for k, v in data.items():\n        setattr(self, k, v)\n    return self.save()\n</code></pre>"},{"location":"response/#pynetbox.core.response.Record.updates","title":"<code>updates(self)</code>","text":"<p>Compiles changes for an existing object into a dict.</p> <p>Takes a diff between the objects current state and its state at init and returns them as a dictionary, which will be empty if no changes.</p> <p>:returns: dict. :example:</p> <p>x = nb.dcim.devices.get(name='test1-a3-tor1b') x.serial '' x.serial = '1234' x.updates()</p> Source code in <code>pynetbox/core/response.py</code> <pre><code>def updates(self):\n    \"\"\"Compiles changes for an existing object into a dict.\n\n    Takes a diff between the objects current state and its state at init\n    and returns them as a dictionary, which will be empty if no changes.\n\n    :returns: dict.\n    :example:\n\n    &gt;&gt;&gt; x = nb.dcim.devices.get(name='test1-a3-tor1b')\n    &gt;&gt;&gt; x.serial\n    ''\n    &gt;&gt;&gt; x.serial = '1234'\n    &gt;&gt;&gt; x.updates()\n    {'serial': '1234'}\n    &gt;&gt;&gt;\n    \"\"\"\n    if self.id:\n        diff = self._diff()\n        if diff:\n            serialized = self.serialize()\n            return {i: serialized[i] for i in diff}\n    return {}\n</code></pre>"},{"location":"response/#pynetbox.core.response.RecordSet","title":"<code> pynetbox.core.response.RecordSet        </code>","text":"<p>Iterator containing Record objects.</p> <p>Returned by <code>Endpoint.all()</code> and <code>Endpoint.filter()</code> methods. Allows iteration of and actions to be taken on the results from the aforementioned methods. Contains Record objects.</p>"},{"location":"response/#pynetbox.core.response.RecordSet--examples","title":"Examples","text":"<p>To see how many results are in a query by calling <code>len()</code>:</p> <pre><code>x = nb.dcim.devices.all()\nlen(x)\n# 123\n</code></pre> <p>Simple iteration of the results:</p> <pre><code>devices = nb.dcim.devices.all()\nfor device in devices:\n    print(device.name)\n\n# test1-leaf1\n# test1-leaf2\n# test1-leaf3\n</code></pre> Source code in <code>pynetbox/core/response.py</code> <pre><code>class RecordSet:\n    \"\"\"Iterator containing Record objects.\n\n    Returned by `Endpoint.all()` and `Endpoint.filter()` methods.\n    Allows iteration of and actions to be taken on the results from the aforementioned\n    methods. Contains Record objects.\n\n    ## Examples\n\n    To see how many results are in a query by calling `len()`:\n\n    ```python\n    x = nb.dcim.devices.all()\n    len(x)\n    # 123\n    ```\n\n    Simple iteration of the results:\n\n    ```python\n    devices = nb.dcim.devices.all()\n    for device in devices:\n        print(device.name)\n\n    # test1-leaf1\n    # test1-leaf2\n    # test1-leaf3\n    ```\n    \"\"\"\n\n    def __init__(self, endpoint, request, **kwargs):\n        self.endpoint = endpoint\n        self.request = request\n        self.response = self.request.get()\n        self._response_cache = []\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self._response_cache:\n            return self.endpoint.return_obj(\n                self._response_cache.pop(), self.endpoint.api, self.endpoint\n            )\n        return self.endpoint.return_obj(\n            next(self.response), self.endpoint.api, self.endpoint\n        )\n\n    def __len__(self):\n        try:\n            return self.request.count\n        except AttributeError:\n            try:\n                self._response_cache.append(next(self.response))\n            except StopIteration:\n                return 0\n            return self.request.count\n\n    def update(self, **kwargs):\n        \"\"\"Updates kwargs onto all Records in the RecordSet and saves these.\n\n        Updates are only sent to the API if a value were changed, and only for\n        the Records which were changed.\n\n        ## Returns\n        True if the update succeeded, None if no update were required.\n\n        ## Examples\n\n        ```python\n        result = nb.dcim.devices.filter(site_id=1).update(status='active')\n        # True\n        ```\n        \"\"\"\n        updates = []\n        for record in self:\n            # Update each record and determine if anything was updated\n            for k, v in kwargs.items():\n                setattr(record, k, v)\n            record_updates = record.updates()\n            if record_updates:\n                # if updated, add the id to the dict and append to list of updates\n                record_updates[\"id\"] = record.id\n                updates.append(record_updates)\n        if updates:\n            return self.endpoint.update(updates)\n        else:\n            return None\n\n    def delete(self):\n        \"\"\"Bulk deletes objects in a RecordSet.\n\n        Allows for batch deletion of multiple objects in a RecordSet.\n\n        ## Returns\n        True if bulk DELETE operation was successful.\n\n        ## Examples\n\n        Deleting offline `devices` on site 1:\n\n        ```python\n        netbox.dcim.devices.filter(site_id=1, status=\"offline\").delete()\n        ```\n        \"\"\"\n        return self.endpoint.delete(self)\n</code></pre>"},{"location":"response/#pynetbox.core.response.RecordSet.delete","title":"<code>delete(self)</code>","text":"<p>Bulk deletes objects in a RecordSet.</p> <p>Allows for batch deletion of multiple objects in a RecordSet.</p>"},{"location":"response/#pynetbox.core.response.RecordSet.delete--returns","title":"Returns","text":"<p>True if bulk DELETE operation was successful.</p>"},{"location":"response/#pynetbox.core.response.RecordSet.delete--examples","title":"Examples","text":"<p>Deleting offline <code>devices</code> on site 1:</p> <pre><code>netbox.dcim.devices.filter(site_id=1, status=\"offline\").delete()\n</code></pre> Source code in <code>pynetbox/core/response.py</code> <pre><code>def delete(self):\n    \"\"\"Bulk deletes objects in a RecordSet.\n\n    Allows for batch deletion of multiple objects in a RecordSet.\n\n    ## Returns\n    True if bulk DELETE operation was successful.\n\n    ## Examples\n\n    Deleting offline `devices` on site 1:\n\n    ```python\n    netbox.dcim.devices.filter(site_id=1, status=\"offline\").delete()\n    ```\n    \"\"\"\n    return self.endpoint.delete(self)\n</code></pre>"},{"location":"response/#pynetbox.core.response.RecordSet.update","title":"<code>update(self, **kwargs)</code>","text":"<p>Updates kwargs onto all Records in the RecordSet and saves these.</p> <p>Updates are only sent to the API if a value were changed, and only for the Records which were changed.</p>"},{"location":"response/#pynetbox.core.response.RecordSet.update--returns","title":"Returns","text":"<p>True if the update succeeded, None if no update were required.</p>"},{"location":"response/#pynetbox.core.response.RecordSet.update--examples","title":"Examples","text":"<pre><code>result = nb.dcim.devices.filter(site_id=1).update(status='active')\n# True\n</code></pre> Source code in <code>pynetbox/core/response.py</code> <pre><code>def update(self, **kwargs):\n    \"\"\"Updates kwargs onto all Records in the RecordSet and saves these.\n\n    Updates are only sent to the API if a value were changed, and only for\n    the Records which were changed.\n\n    ## Returns\n    True if the update succeeded, None if no update were required.\n\n    ## Examples\n\n    ```python\n    result = nb.dcim.devices.filter(site_id=1).update(status='active')\n    # True\n    ```\n    \"\"\"\n    updates = []\n    for record in self:\n        # Update each record and determine if anything was updated\n        for k, v in kwargs.items():\n            setattr(record, k, v)\n        record_updates = record.updates()\n        if record_updates:\n            # if updated, add the id to the dict and append to list of updates\n            record_updates[\"id\"] = record.id\n            updates.append(record_updates)\n    if updates:\n        return self.endpoint.update(updates)\n    else:\n        return None\n</code></pre>"},{"location":"virtualization/","title":"Virtualization","text":"<p>This page documents special methods available for Virtualization models in pyNetBox.</p> <p>Standard API Operations</p> <p>Standard CRUD operations (<code>.all()</code>, <code>.filter()</code>, <code>.get()</code>, <code>.create()</code>, <code>.update()</code>, <code>.delete()</code>) follow NetBox's REST API patterns. Refer to the NetBox API documentation for details on available endpoints and filters.</p>"},{"location":"virtualization/#virtual-machines","title":"Virtual Machines","text":""},{"location":"virtualization/#config-rendering","title":"Config Rendering","text":"<p>The <code>render_config</code> property renders virtual machine configuration based on config contexts and templates.</p> <p>Example: <pre><code>vm = nb.virtualization.virtual_machines.get(name='web-vm-01')\nconfig = vm.render_config.create()\nprint(config)\n</code></pre></p>"},{"location":"virtualization/#pynetbox.models.virtualization.VirtualMachines.render_config","title":"<code>pynetbox.models.virtualization.VirtualMachines.render_config</code>  <code>property</code> <code>readonly</code>","text":"<p>Represents the <code>render-config</code> detail endpoint.</p> <p>Returns a DetailEndpoint object that is the interface for viewing response from the render-config endpoint.</p> <p>:returns: class:<code>.DetailEndpoint</code></p> <p>:Examples:</p> <p>vm = nb.virtualization.virtual_machines.get(123) vm.render_config.create()</p>"},{"location":"development/","title":"Development","text":"<p>Thanks for your interest in contributing to pynetbox! This introduction covers a few important things to know before you get started.</p>"},{"location":"development/#the-code","title":"The Code","text":"<p>pynetbox is maintained on GitHub. GitHub also serves as one of our primary discussion forums. While all the code and discussion is publicly accessible, you'll need to register for a free GitHub account to engage in participation. Most people begin by forking the pynetbox repository under their own GitHub account to begin working on the code.</p> <p>There are two permanent branches in the repository:</p> <ul> <li><code>master</code> - Active development for the upcoming patch release. Pull requests will typically be based on this branch unless they introduce breaking changes that must be deferred until the next major release.</li> <li><code>feature</code> - New feature work to be introduced in the next major release.</li> </ul> <p>pynetbox components are arranged into modules:</p> <ul> <li><code>core/</code> - Core functionality including API interaction, response handling, and query building</li> <li><code>models/</code> - Model definitions for different NetBox object types</li> <li><code>tests/</code> - Test suite including unit and integration tests</li> <li><code>docs/</code> - Documentation files</li> </ul>"},{"location":"development/#proposing-changes","title":"Proposing Changes","text":"<p>All substantial changes made to the code base are tracked using GitHub issues. Feature requests, bug reports, and similar proposals must all be filed as issues and approved by a maintainer before work begins. This ensures that all changes to the code base are properly documented for future reference.</p> <p>To submit a new feature request or bug report for pynetbox, select and complete the appropriate issue template. Once your issue has been approved, you're welcome to submit a pull request containing your proposed changes.</p> <p>Note</p> <p>Avoid starting work on a proposal before it has been accepted. Not all proposed changes will be accepted, and we'd hate for you to waste time working on code that might not make it into the project.</p>"},{"location":"development/#getting-help","title":"Getting Help","text":"<p>There are two primary forums for getting assistance with pynetbox development:</p> <ul> <li>GitHub discussions - The preferred forum for general discussion and support issues. Ideal for shaping a feature requests prior to submitting an issue.</li> <li>#netbox on NetDev Community Slack - Good for quick chats. Avoid any discussion that might need to be referenced later on, as the chat history is not retained indefinitely.</li> </ul> <p>Note</p> <p>Don't use GitHub issues to ask for help: These are reserved for proposed code changes only.</p>"},{"location":"development/#governance","title":"Governance","text":"<p>pynetbox follows the benevolent dictator model of governance, with the lead maintainer ultimately responsible for all changes to the code base. While community contributions are welcomed and encouraged, the lead maintainer's primary role is to ensure the project's long-term maintainability and continued focus on its primary functions.</p>"},{"location":"development/#licensing","title":"Licensing","text":"<p>The entire pynetbox project is licensed as open source under the Apache 2.0 license. This is a very permissive license which allows unlimited redistribution of all code within the project. Note that all submissions to the project are subject to the same license. </p>"},{"location":"development/getting-started/","title":"Getting Started","text":"<p>This guide will help you get started with development on pynetbox. It covers setting up your development environment and running tests.</p>"},{"location":"development/getting-started/#development-environment","title":"Development Environment","text":"<ol> <li>Fork the pynetbox repository on GitHub</li> <li>Clone your fork locally</li> <li>Create a virtual environment and install development dependencies:</li> </ol> <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip install -e \".[dev]\"\n</code></pre>"},{"location":"development/getting-started/#running-tests","title":"Running Tests","text":"<p>pynetbox uses pytest for testing. The test suite includes both unit tests and integration tests.</p>"},{"location":"development/getting-started/#unit-tests","title":"Unit Tests","text":"<p>To run the unit tests:</p> <pre><code>pytest tests/unit\n</code></pre>"},{"location":"development/getting-started/#integration-tests","title":"Integration Tests","text":"<p>The integration tests require a running NetBox instance. The test suite uses pytest-docker to spin up NetBox instances in Docker containers.</p> <p>To run the integration tests:</p> <pre><code>pytest tests/integration\n</code></pre> <p>You can specify which versions of NetBox to test against using the <code>--netbox-versions</code> flag:</p> <pre><code>pytest tests/integration --netbox-versions 4.2 4.3 4.4\n</code></pre>"},{"location":"development/getting-started/#running-specific-tests","title":"Running Specific Tests","text":"<p>You can run specific test files or test functions:</p> <pre><code># Run a specific test file\npytest tests/unit/test_api.py\n\n# Run a specific test function\npytest tests/unit/test_api.py::test_api_status\n\n# Run tests matching a pattern\npytest -k \"test_api\"\n</code></pre>"},{"location":"development/getting-started/#test-coverage","title":"Test Coverage","text":"<p>To run tests with coverage reporting:</p> <pre><code>pytest --cov=pynetbox tests/\n</code></pre>"},{"location":"development/getting-started/#submitting-pull-requests","title":"Submitting Pull Requests","text":"<p>Once you're happy with your work and have verified that all tests pass, commit your changes and push it upstream to your fork. Always provide descriptive (but not excessively verbose) commit messages. Be sure to prefix your commit message with the word \"Fixes\" or \"Closes\" and the relevant issue number (with a hash mark). This tells GitHub to automatically close the referenced issue once the commit has been merged.</p> <pre><code>git commit -m \"Closes #1234: Add IPv5 support\"\ngit push origin\n</code></pre> <p>Once your fork has the new commit, submit a pull request to the pynetbox repo to propose the changes. Be sure to provide a detailed accounting of the changes being made and the reasons for doing so.</p> <p>Once submitted, a maintainer will review your pull request and either merge it or request changes. If changes are needed, you can make them via new commits to your fork: The pull request will update automatically.</p> <p>Warning</p> <p>Remember, pull requests are permitted only for accepted issues. If an issue you want to work on hasn't been approved by a maintainer yet, it's best to avoid risking your time and effort on a change that might not be accepted. (The one exception to this is trivial changes to the documentation or other non-critical resources.) </p>"},{"location":"development/release-checklist/","title":"Release Checklist","text":"<p>This document outlines the steps required to prepare and publish a new release of pynetbox.</p>"},{"location":"development/release-checklist/#pre-release-tasks","title":"Pre-Release Tasks","text":"<ol> <li> <p>Ensure all tests are passing:    <pre><code>pytest\n</code></pre></p> </li> <li> <p>Update version number in <code>pynetbox/__init__.py</code></p> </li> <li>Update documentation for any new features or changes</li> <li>Check NetBox Docker releases:<ul> <li>Visit https://github.com/netbox-community/netbox-docker/releases</li> <li>Review the latest NetBox Docker releases and their corresponding NetBox versions</li> <li>Update supported NetBox versions in <code>tests/integration/conftest.py</code> if needed</li> <li>Ensure the <code>get_netbox_docker_version_tag</code> function in <code>tests/integration/conftest.py</code> is updated with any new version mappings</li> </ul> </li> </ol>"},{"location":"development/release-checklist/#release-tasks","title":"Release Tasks","text":"<ol> <li> <p>Create a new release branch from <code>master</code>:    <pre><code>git checkout master\ngit pull\ngit checkout -b release/vX.Y.Z\n</code></pre></p> </li> <li> <p>Commit version and changelog updates:    <pre><code>git commit -m \"Prepare release vX.Y.Z\"\n</code></pre></p> </li> <li> <p>Create a pull request to merge the release branch into <code>master</code></p> </li> <li> <p>Once merged, use github to create a new release:</p> <ol> <li>Go to the GitHub repository</li> <li>Click \"Releases\" in the right sidebar</li> <li>Click \"Create a new release\"</li> <li>Create a new tag (e.g., vX.Y.Z)</li> <li>Use the changelog content as the release description</li> <li>Publish the release</li> </ol> <p>The GitHub release will automatically trigger the workflow to publish to PyPI.</p> </li> </ol>"},{"location":"development/release-checklist/#supported-netbox-versions","title":"Supported NetBox Versions","text":"<p>pynetbox aims to support the current and previous two minor versions of NetBox. The supported versions are defined in <code>tests/integration/conftest.py</code> and should be updated as part of the release process. </p>"}]}